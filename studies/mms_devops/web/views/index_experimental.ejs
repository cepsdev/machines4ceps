<!DOCTYPE html>
<html lang=en>
<!-- 
    
    Cool effects

    https://blog.trackduck.com/2015/06/10/15-impressive-pop-animation-effects-codepen/
    
    
    -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="(c) ceps technologies, all rights reserved">
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="jquery-ui/jquery-ui.min.css" rel="stylesheet">
    <link href="font-awesome/css/font-awesome.min.css" rel="stylesheet">   
    <link href="rollaut/rollaut_basic.css" rel="stylesheet">
     
<style>
    @font-face {
   font-family: 'Material Icons';
   font-style: normal;
   font-weight: 400;
   src: url(iconfont/MaterialIcons-Regular.eot); /* For IE6-8 */
   src: local('Material Icons'),
        local('MaterialIcons-Regular'),
        url(iconfont/MaterialIcons-Regular.woff2) format('woff2'),
        url(iconfont/MaterialIcons-Regular.woff) format('woff'),
        url(iconfont/MaterialIcons-Regular.ttf) format('truetype');
}

.material-icons {
  font-family: 'Material Icons';
  font-weight: normal;
  font-style: normal;
  font-size: 24px;  /* Preferred icon size */
  display: inline-block;
  line-height: 1;
  text-transform: none;
  letter-spacing: normal;
  word-wrap: normal;
  white-space: nowrap;
  direction: ltr;

  /* Support for all WebKit browsers. */
  -webkit-font-smoothing: antialiased;
  /* Support for Safari and Chrome. */
  text-rendering: optimizeLegibility;

  /* Support for Firefox. */
  -moz-osx-font-smoothing: grayscale;

  /* Support for IE. */
  font-feature-settings: 'liga';
}
        /* Rules for sizing the icon. */
.material-icons.md-18 { font-size: 18px; }
.material-icons.md-24 { font-size: 24px; }
.material-icons.md-36 { font-size: 36px; }
.material-icons.md-48 { font-size: 48px; }

/* Rules for using icons as black on a light background. */
.material-icons.md-dark { color: rgba(0, 0, 0, 0.54); }
.material-icons.md-dark.md-inactive { color: rgba(0, 0, 0, 0.26); }

/* Rules for using icons as white on a dark background. */
.material-icons.md-light { color: rgba(255, 255, 255, 1); }
.material-icons.md-light.md-inactive { color: rgba(255, 255, 255, 0.3); }

.material-icons.md-18 { font-size: 18px; }
.material-icons.md-24 { font-size: 24px; }
.material-icons.md-36 { font-size: 36px; }
.material-icons.md-48 { font-size: 48px; }
.material-icons.md-dark { color: rgba(0, 0, 0, 0.54); }
.material-icons.md-dark.md-inactive { color: rgba(0, 0, 0, 0.26); }

.material-icons.md-light { color: rgba(255, 255, 255, 1); }
.material-icons.md-light.md-inactive { color: rgba(255, 255, 255, 0.3); }
.material-icons.orange600 { color: #FB8C00; }

  </style>
    <title>MediaMarktSaturn - Rollouts</title>
</head>

<body style="padding-top: 70px;">
    <nav class="navbar navbar-expand-md  navbar-dark bg-dark fixed-top">
            <a class="navbar-brand">
              <!-- >sup>Roll<sub><span class="text-primary" style="font-size:22px;">A</span></sub>ut</sup-->
            </a>
            <h3 style="color:white;vertical-align:center;text-align:center;"></h3>

        <div class="collapse navbar-collapse">
            <ul class="navbar-nav mr-auto mt-2 mt-lg-0">
                
            </ul>
            <span class="badge badge-danger" id="nav_info_connection">
             <div style="float:left;margin:2px;" class="rollaut_connection_loader"></div>
             <span style="vertical-align: sub;">Not Connected</span>
            </span>
        </div>
    </nav>
    <main role="main" class="container">
    <div class="row">
        <div class="col-xs-6 col-sm-12">
            <h2><span id="page_title"></span></h2>
        </div>
    </div>
    <div class="row"  id="searchfield_row">
        <div class="col-xs-1 col-sm-1 col-md-1"></div>
        <div class="col-xs-10 col-sm-10 col-md-10" 
             style="border-left:solid 1px;
                    border-right:solid 1px;
                    min-height:3000px;"

        >
          <h2 style="text-align: center;" >Scheduled Rollouts</h2>

          <div class="form-group" style="padding-left: 4px;padding-right: 4px;">
             <label for="search_statemachines"></label>
               <input type="text" 
                  class="form-control" 
                  id="input_search_timeline" 
                  aria-describedby="input_search_timeline" placeholder="Search Rollouts">
                 <small id="input_search_timeline" class="form-text text-muted"></small>
          </div>
              <div id="info_tiles" 
                xxstyle="display:block;overflow:hidden;position:absolute;background-color: black;">
             </div>
             
        </div>
        <div class="col-xs-1 col-sm-1 col-md-1"></div>        
    </div>
  </main>

<div class="modal" 
       id="dlg_rollout_details" 
       tabindex="-1" 
       role="dialog" 
       aria-labelledby="dlg_rollout_details" 
       style="z-index: 10000;">

    <div class="modal-dialog modal-lg modal-dialog-centered" role="document">
        <div class="modal-content">
            <div class="modal-header">
              <h4 class="modal-title" id="dlg_select_a_signal_label">Rollout Details</h4>
              <button type="button" class="close" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">&times;</span></button>
            </div>
            <div id="dlg_rollout_details_body" class="modal-body">
                
            </div>
            <div class="modal-footer" id="dlg_rollout_details_footer">
            </div>
        </div>
    </div>
</div>


</body>

<script src="jquery/js/jquery.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>
<script src="rollaut/tiles.js"></script>

<script>

let ceps_core_channel;
let timeLineWidget = null;

$("#input_search_timeline").keyup(function(e){
  let t = $("#input_search_timeline").val();
  let vt = t.split(" ");
  let v = [];
  for(let i = 0; i < vt.length; ++i){
    if (vt[i].length == 0 || vt[i] == " " ) continue;
    if (vt[i].startsWith("\"")){
      let tt = vt[i].substring(1);
      if (tt.endsWith("\"")) 
       tt = tt.substring(0,tt.length-1);

      let s = tt;++i;
      
      for(;i<vt.length;++i){
        if (vt[i].length == 0 || vt[i] == " " ) continue;
        if (vt[i].endsWith("\"")){
          s += " "+ vt[i].substr(0,vt[i].length-1);
          break;
        }
        else s += " "+vt[i];
      }
      v.push(s);
      continue;
    }
    v.push(vt[i]);
  }
  //console.log(v);
  if (v.length == 0){
    timeLineWidget.applyFilter( function() {return true;});
  } else {
    timeLineWidget.applyFilter(
      function(tile_idx,data){
        for(let i = 0; i != v.length;++i){
          if (data.title[tile_idx].indexOf(v[i]) != -1) return true;
        }
        return false;
      }
    );
  }
});


function extractAttributesFromStaccatoEntity(e){
     let r = {
     }
     for(let i = 0; i != e.children.length;++i){
        if (e.children[i]["class"] != "attribute") 
          continue;
        r[e.children[i]["name"]] = e.children[i]["value"];
      }
     return r;
}

function utilsTranslateHealthToTileStatus(health){
  if (health == null) return TILE_STATUS_INACTIVE;
  return { 
      "ok":TILE_STATUS_OK,
      "complete":TILE_STATUS_DONE,
      "failed":TILE_STATUS_ERROR,
      "failure":TILE_STATUS_ERROR,
      "fatal":TILE_STATUS_ERROR,
      "critical":TILE_STATUS_WARN,
      "n/a":TILE_STATUS_INACTIVE
  } [health];       
}

 let staccatoAPI = null;
 let build_running_rollout_overview_dlg_update = null;

 function issue_rollaut_staccato_write_command (data){
  staccatoAPI.main_socket.send(JSON.stringify(
    { what  : "command",
      name  : "write_attribute_value",
      params: [
        { loc       : "rollouts/scheduled",
          entity_id : data.entity.raw.id.toString(),
          attribute : "scheduled_time_unix_time",
          value     : Math.round(Date.now()/1000) 
        }
      ]
    }
  ));
 }

 
 
 let update_running_rollout_overview_dlg_store_info_timeline_timer = null;
 function build_running_rollout_overview_dlg_store_info_timeline(body_div,status,cov,steps,store,tiles,tile_index){
  
  function get_time_info(step_idx){
    let outer = document.createElement("div");
    //outer.setAttribute("style","color:rgba(100,100,100,100);");
    let inner = document.createElement("h6");
    let t = "";
    let date = new Date(1000*(tiles.tiles_widget.data.info.enter_time(tile_index,step_idx).secs_since_uptime+store.up_time));
    t = date.toLocaleTimeString();
    inner.appendChild(document.createTextNode(t));
    outer.append(inner);
    return outer;
  };

  let tdls = [];
  let tdrs = [];
  
  function update_running_rollout_overview_dlg_store_info_timeline(){
    let cur_state = tiles.tiles_widget.data.info.state[tile_index];
    for(let i = 0; i != steps.length && i < cur_state;++i){
       tdrs[i].setAttribute("style","text-align:left;padding:4px;");
       if (tdls[i].firstChild != null)
        tdls[i].removeChild(tdls[i].firstChild);
       tdls[i].appendChild(get_time_info(i));
       tdls[i].setAttribute("style",
        `color:rgba(100,100,100,100);
         border-right: 2px solid;
         border-right-color: rgba(100,100,100,150);
         width: 100px;
         margin-top:10px;`);
    }

    tdrs[cur_state].setAttribute("style",
     `font-weight: bold;border: 2px solid grey;text-align:left;padding:4px;
      box-shadow: 2px 5px 4px #888888;
     `);
    
    if (tdls[cur_state].firstChild != null)
        tdls[cur_state].removeChild(tdls[cur_state].firstChild);
        tdls[cur_state].appendChild(get_time_info(cur_state));

    tdls[cur_state].setAttribute("style",
     `font-weight:bold;
      color:black;
      border-right: 2px solid;
      border-right-color: rgba(100,100,100,150);
      width: 100px;
      margin-top:10px;`);


    for(let i = cur_state + 1; i != steps.length;++i){
       tdrs[i].setAttribute("style","text-align:left;padding:4px;filter: opacity(0.4);");
       if (tdls[i].firstChild != null)
        tdls[i].removeChild(tdls[i].firstChild);
    }
  }

  if (update_running_rollout_overview_dlg_store_info_timeline_timer != null)
   clearInterval(update_running_rollout_overview_dlg_store_info_timeline_timer);
   update_running_rollout_overview_dlg_store_info_timeline_timer = 
    setInterval(update_running_rollout_overview_dlg_store_info_timeline,1000);

  let outer_div = document.createElement("div");
  let tbl = document.createElement("table");
  tbl.setAttribute("style","");
  let current_state = store.state;

  for(let i = 0; i != steps.length;++i){
    let tr = document.createElement("tr");
    let tdl = document.createElement("td");
    tdls.push(tdl);
    tdl.setAttribute("style",
     `border-right: 2px solid;border-right-color: rgba(100,100,100,150);`+
     `width: 100px;margin-top:10px;`
    );
    if (i <= current_state ) tdl.appendChild(get_time_info(i));
    let tdr = document.createElement("td");
    tdrs.push(tdr);
    if (i <= current_state) 
     tdr.setAttribute("style","text-align:left;padding:4px;");
    else 
     tdr.setAttribute("style","text-align:left;padding:4px;filter: opacity(0.4);");
    let title = document.createElement('h8');
    let title_str = document.createTextNode(steps[i].description);
    title.appendChild(title_str);
    tdr.appendChild(title);
    tr.appendChild(tdl);
    tr.appendChild(tdr);
    let tdl_spacer = document.createElement("td");
    tdl_spacer.setAttribute("style","width:20px;");
    tr.appendChild(tdl_spacer);
    tbl.appendChild(tr);
    let tr_spacer = document.createElement("tr");
    tr_spacer.appendChild(document.createElement("td"));
    tr_spacer.appendChild(document.createElement("td"));
    tr_spacer.setAttribute("style","height:15px;");
    tbl.appendChild(tr_spacer);
  }
  outer_div.appendChild(tbl);
  body_div.appendChild(outer_div);
  update_running_rollout_overview_dlg_store_info_timeline();
 }

 function build_running_rollout_overview_dlg_store_info(parent,status,cov,steps,store,tiles,index){
  function get_header_class() {
      if (status == undefined || status == undefined) return "bg-secondary";
      if (status == TILE_STATUS_OK) return "bg-primary";
      if (status == TILE_STATUS_WARN) return "bg-warning";
      if (status == TILE_STATUS_ERROR) return "bg-danger";
      return "bg-success";      
   };

   for(;parent.firstChild != null;) parent.removeChild(parent.firstChild);
   let outer_div = document.createElement("div");
   outer_div.setAttribute("style",`width:400px;`);

   let header_div = document.createElement("div");
   header_div.setAttribute("style",`position:relative;left:0px;top:0px;width:100%;`);
   header_div.setAttribute("class",get_header_class());
   let header_sub_div_top = document.createElement("div");
   header_sub_div_top.setAttribute("style","height:1em;");
   let header_sub_div_middle = document.createElement("div");
   header_sub_div_middle.setAttribute("style","color:#F8F8FF;padding-left:12px;");
   let header_sub_div_bottom = document.createElement("div");
   header_sub_div_bottom.setAttribute("style","color:#F8F8FF;padding-right:12px;margin-bottom:10px;text-align:right;");

   header_div.appendChild(header_sub_div_top);
   header_div.appendChild(header_sub_div_middle);
   header_div.appendChild(header_sub_div_bottom);
   let middle_text = document.createTextNode(store.title);
   let middle_h3 = document.createElement("h3");
   middle_h3.appendChild(middle_text);
   header_sub_div_middle.appendChild(middle_h3);
   let middle_main = middle_h3;
   let bottom_text = document.createTextNode(`${Math.trunc(cov*10000.0)/100}%`);
   let h5_elem = document.createElement("h5");
   h5_elem.appendChild(bottom_text);
   bottom_main = h5_elem;
   header_sub_div_bottom.appendChild(h5_elem);
   outer_div.appendChild(header_div);
   let body_div = document.createElement("div");
   body_div.setAttribute("style",`overflow:scroll;height:220px;`);
   build_running_rollout_overview_dlg_store_info_timeline(body_div,status,cov,steps,store,tiles,index);
   outer_div.appendChild(body_div);
   let footer_div = document.createElement("div");
   footer_div.innerHTML = `<div class="form-group" style="width:140px;margin:0 auto;">
    <button style="float:left;margin:8px;" 
                    id="XXXX" 
                    type="button" 
                    class="btn btn-outline-primary btn-sm" 
                    >Kill</button>
    <button style="float:right;margin:8px;" 
                    id="YYY" 
                    type="button" 
                    class="btn btn-outline-primary btn-sm" 
                    >Restart</button>                    
    </div>`;
   outer_div.appendChild(footer_div);
   parent.appendChild(outer_div);   
 }

 function build_running_rollout_overview_dlg (id,idx,data,header,body,footer){
  
   let cw = 300;
   let ch = 300;
   let radius = Math.floor(cw/2 * 0.45);
   let lw1 = 40;
  
   body.innerHTML =
   `
   <div style="text-align:center;align:center;" >
    <div>    
    <div style="margin:10px;float:left;">
      <canvas id="running_rollout_overview_dlg_canvas" width="${cw}px" height="${ch}px" style="background-color:white;">
     </canvas>
    </div>
    <div id = "running_rollout_overview_dlg_store_info" style="width:auto;margin:auto;float:right;">
     <div style="width:100%;height:100%;text-align:center;color:rgba(140,140,140,150);">
     <h4 style="margin-top:150px;">Click on a market for full details.</h4></div>
    </div>
    </div>
    
    <div class="form-group" style="padding-left: 4px;padding-right: 4px;">
      <label for="rollout_overview_dlg_search_statemachines"></label>
      <input type="text" 
                  class="form-control" 
                  id="rollout_overview_dlg_input_search_statemachines" 
                  aria-describedby="search_statemachinesHelp" placeholder="Search Stores">
       <small id="rollout_overview_dlg_search_statemachinesHelp" class="form-text text-muted"></small>
    </div>

    <div style = "height: ${Math.floor(window.outerHeight*0.30)}px;overflow: scroll;">
     <div id="build_running_rollout_overview_dlg_details">

     </div>
    </div>
   `;
   let attrs = extractAttributesFromStaccatoEntity(data.entity.raw);
   let id2idx = new Map;

   let stores = attrs.stores;
   let steps = attrs.steps;

   for(let i = 0; i != stores.length;++i){
    id2idx.set(stores[i]["id"] , i);
   }

   let tiles = create_tiles_deck(
     document.getElementById("build_running_rollout_overview_dlg_details"), 
     {
       getSize : function () {return stores.length;},
       getTitle : function (idx) {return stores[idx]["name"];},
       getState : function(idx) {return 0;},
       getStatus: function(idx) { 
             return utilsTranslateHealthToTileStatus(stores[idx]["health"]);           
           },
       getCoverage: function(idx) { 
             return stores[idx]["coverage"];           
       },       
       getTile2StatesMapping  : function() { return {}; },
       getState2VisitedStates : function() { return {}; },
       getState2RootMapping   : function() { return {}; },
       getState2LabelMapping  : function() { 
         let m = {};
         for(let i = 0; i != steps.length; ++i) {
           m[i] = steps[i].description;
         } 
       },
       getStateLabels  : function() { 
         let v = [];
         for(let i = 0; i != steps.length; ++i) {
           v.push(steps[i].description);
         }
         return v;
       },
       getEnterTime : function (idx,state){
         return {secs_since_uptime:stores[idx]["entering_times"][state],msecs_since_uptime:0};         
       },
       getExitTime : function (idx,state) {
         return {secs_since_uptime:stores[idx]["exiting_times"][state],msecs_since_uptime:0};
       },
       getUpTime : function(){
         return data.attributes["start_time_unix_time"];
       },
       getEnterTimes          : function(idx) {return stores[idx]["entering_times"];},
       getExitTimes           : function(idx) {return stores[idx]["exiting_times"];}

     },
     {},
     {}
   );
   tiles.tiles_widget.register_click_tile_handler(
     function (index,data){
       build_running_rollout_overview_dlg_store_info(
         document.getElementById("running_rollout_overview_dlg_store_info"),
         tiles.tiles_widget.data.info.status[index],
         tiles.tiles_widget.data.info.cov[index],
         steps,
         data,
         tiles,
         index);
     }
   );


   let update_running_rollout_overview_func = function () {
       let attrs = extractAttributesFromStaccatoEntity(data.entity.raw);
       //Update Tiles
       stores = attrs.stores;
       for(let i = 0; i != stores.length;++i) {
        let tile_idx = id2idx.get(stores[i]["id"]);
        if (stores[i]["coverage"] != tiles.tiles_widget.data.info.cov[tile_idx]) 
         tiles.tiles_widget.set_coverage(tile_idx,stores[i]["coverage"]);
        let new_status = utilsTranslateHealthToTileStatus(stores[i]["health"]);
        if (new_status != tiles.tiles_widget.data.info.status[tile_idx])
         tiles.tiles_widget.set_status(tile_idx,new_status);
         tiles.tiles_widget.set_state(tile_idx,stores[i]["current_state"]);
       }       

       //console.log(attrs);
       let cov_critical = 0.0;
       let cov_fatal = 0.0;
       let cov_complete = 0.0;
       let n_critical = 0;
       let n_fatal = 0;
       let n_complete = 0;
       let n_stores = attrs.stores.length;

       for(let i = 0; i != n_stores; ++i){
         if (attrs.stores[i].health == "critical") { 
           cov_critical += 
            (1/n_stores)*attrs.coverage;
            ++n_critical;
          }
         else if (attrs.stores[i].health == "fatal") cov_fatal +=  
          (1/n_stores)*attrs.coverage;
         else if (attrs.stores[i].health == "complete") cov_complete +=  
          (1/n_stores)*attrs.coverage;        
       }



       let c = document.getElementById("running_rollout_overview_dlg_canvas");
       let ctx = c.getContext("2d");
       ctx.clearRect(0, 0, cw, ch);
       ctx.imageSmoothingEnabled = true;
       let center_x = cw/2;
       let center_y = ch/2;
       //background

       ctx.beginPath();

       ctx.shadowOffsetX = 2;
       ctx.shadowOffsetY = 2;
       ctx.shadowBlur = 4;
       ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
       ctx.lineWidth = lw1;
       ctx.strokeStyle = "rgba(173, 216, 230,0.2)";
       ctx.arc(center_x, center_y, radius, 0, 2 * Math.PI);
       ctx.stroke();

       //Coverage: ALL

       ctx.beginPath();
       ctx.lineWidth = lw1;
       ctx.strokeStyle = "rgba(0, 120, 204,0.8)";//"rgba(102, 204, 0,0.9)";
       ctx.arc(center_x, center_y, radius, - 1/2 * Math.PI, - 1/2 * Math.PI +  2 * Math.PI * attrs.coverage);
       ctx.stroke();

       ctx.font = "20px Arial";
       let t = `${ Math.round(attrs.coverage*10000)/100 }%`;
       let m = ctx.measureText(t);
       ctx.lineWidth = 1;
       ctx.fillStyle = ctx.strokeStyle;

       ctx.fillText(t, center_x - m.width/2, center_y+7);
       //ctx.fillText(t, center_x , center_y );

      //Coverage: COMPLETE
      let add_info = 0;

      if (cov_complete > 0.01) {
       ++add_info;
       ctx.beginPath();
       ctx.lineWidth = lw1;
       ctx.strokeStyle = "rgba(102, 204, 0,0.9)";
       ctx.arc(center_x, center_y, radius, - 1/2 * Math.PI, - 1/2 * Math.PI +  2 * Math.PI * (cov_complete+cov_critical+cov_fatal) );
       ctx.stroke();
       ctx.font = "10px Arial";
       let t = `${ Math.round(cov_complete*10000)/100 }%`;
       let m = ctx.measureText(t);
       ctx.lineWidth = 1;
       ctx.fillStyle = ctx.strokeStyle;

       ctx.shadowOffsetX = 0;
       ctx.shadowOffsetY = 0;
       ctx.shadowBlur = 0;

       ctx.font = "20px Arial";
       ctx.fillStyle = ctx.strokeStyle = "rgba(102, 204, 0,1.0)";

     
       ctx.fillText(t, 
        -m.width + center_x + 1.7*radius*Math.cos( 2 * Math.PI * (1/2*cov_complete +cov_critical+cov_fatal) - 1/2*Math.PI), 
        center_y + 1.7*radius*Math.sin( 2* Math.PI * (1/2*cov_complete +cov_critical+cov_fatal) - 1/2*Math.PI));

      }
      //Coverage: CRITICAL
      if (cov_critical > 0.01) {
        ++add_info;
       ctx.beginPath();
       ctx.lineWidth = lw1;
       ctx.strokeStyle = "rgba(255, 192, 24,0.8)";
       ctx.arc(center_x, center_y, radius, - 1/2 * Math.PI, - 1/2 * Math.PI +  2 * Math.PI * (cov_critical+cov_fatal) );
       ctx.stroke();

       ctx.font = "20px Arial";
       let t = `${ Math.round(cov_complete*10000)/100 }%`;
       let m = ctx.measureText(t);
       ctx.lineWidth = 1;
       ctx.fillStyle = ctx.strokeStyle = "rgba(255, 192, 24,1.0)";
       ctx.shadowOffsetX = 0;
       ctx.shadowOffsetY = 0;
       ctx.shadowBlur = 0;
       
       ctx.fillText(t, center_x + 1.4*radius*Math.cos( 2 * Math.PI * (cov_fatal+1/2*cov_critical) - 1/2*Math.PI), 
                       center_y + 1.4*radius*Math.sin( 2* Math.PI * (cov_fatal+1/2*cov_critical) - 1/2*Math.PI));

      }
      //Coverage: FATAL
      if (cov_fatal > 0.01) {
       ctx.beginPath();
       ctx.shadowOffsetX = 2;
       ctx.shadowOffsetY = 2;
       ctx.shadowBlur = 4;
       ctx.lineWidth = lw1;
       ctx.strokeStyle = "rgba(255, 50, 2,0.8)";
       ctx.arc(center_x, center_y, radius, - 1/2 * Math.PI, - 1/2 * Math.PI +  2 * Math.PI * (cov_fatal) );
       ctx.stroke();

       ctx.shadowOffsetX = 0;
       ctx.shadowOffsetY = 0;
       ctx.shadowBlur = 0;

       ctx.font = "20px Arial";
       let t = `${ Math.round(cov_fatal*10000)/100 }%`;
       ctx.fillStyle = ctx.strokeStyle = "rgba(255, 50, 2,1.0)";

     
       ctx.fillText(t, center_x + 1.4*radius*Math.cos( 2 * Math.PI * (1/2*cov_fatal) - 1/2*Math.PI), 
                       center_y + 1.4*radius*Math.sin( 2* Math.PI * (1/2*cov_fatal) - 1/2*Math.PI));

     }

    };

   update_running_rollout_overview_func();

   build_running_rollout_overview_dlg_update = setInterval(
     update_running_rollout_overview_func,1000);
 }

 function build_scheduled_rollout_overview_dlg(id,groupIndex,idx,data,header,body,footer){
   let scheduled_time = data.attributes.scheduled_time_unix_time;
   let jd = new Date(scheduled_time*1000);
   let now = Math.floor(Date.now()/1000);
   let due_string = "";
   if( scheduled_time - now > 0  ){
     let t = scheduled_time - now;
     let days = Math.floor(t / (3600*24));
     let hours = Math.floor((t - days * 3600*24) / 3600);
     let minutes = Math.floor((t - days * 3600*24 - hours * 3600) / 60);
     let seconds = Math.floor((t - days * 3600*24 - hours * 3600 - minutes * 60));
     if (days > 0)
      due_string = `${days} days`;
     if (hours > 0)
      due_string = due_string + ` ${hours} hours`;
     if (minutes > 0)
      due_string = due_string + ` ${minutes} minutes`;
     if (days == 0 && hours == 0)
     due_string = due_string + ` ${seconds} seconds`;
     due_string = `(due in ${due_string})`;
   }

   let launch_btn = "";
   if (data.attributes["processing_status"] == null || data.attributes["processing_status"] == "stopped"){
    launch_btn = `<button id="rollout_launch_btn" class="float-sm-left btn btn-primary mb-2">Launch</button>`;  
   }
   
   body.innerHTML = `
   <div style="" >
     <i class="material-icons" style="vertical-align:top;">schedule</i>
     <span style="vertical-align:top;">${jd.toLocaleString()}</span>
     <span>${due_string}</span>
     </div>        
   `;

   footer.innerHTML = `
   <table style="width:100%;">
    <tr>
      <td style=""></td>
    <td> <div style="margin-left: auto;margin-right: auto;width: 2em">${launch_btn}</div></td>
    <td style=""></td>
    </tr>
   </table>
   `;

   if (launch_btn.length > 0){
     let btn = document.getElementById("rollout_launch_btn");
     btn.onclick = function (){
      timeLineWidget.setActive(groupIndex,idx,false);
      $("#dlg_rollout_details").modal("hide");
      issue_rollaut_staccato_write_command (data);
     }
   }
 }

 function build_rollout_overview_dlg(id,groupIndex,idx,data){
   if (build_running_rollout_overview_dlg_update != null) {
     clearInterval(build_running_rollout_overview_dlg_update);
     build_running_rollout_overview_dlg_update = null;
   }
   let dlg = document.getElementById(id);
   let divs = [];
   for(let i = 0; i != dlg.firstElementChild.firstElementChild.children.length;++i){
     let tg = dlg.firstElementChild.firstElementChild.children[i];
     if(tg.tagName != "DIV") continue;
     divs.push(tg);
   } 
   let header = divs[0].firstElementChild;
   let body = divs[1];
   let footer = divs[2];
   for(;body.firstChild!=null;)body.removeChild(body.firstChild);
   for(;footer.firstChild!=null;)footer.removeChild(footer.firstChild);
   header.innerHTML = data.title;
   if (data.attributes["processing_status"] != null)
    build_running_rollout_overview_dlg(id,idx,data,header,body,footer);
   else
    build_scheduled_rollout_overview_dlg(id,groupIndex,idx,data,header,body,footer);
}

 function test_data(data_size){
   let THIS = {
     filters           : [],
     permutations      : [],
     size              : data_size,
     up_since          : undefined,
     info              : {
       status      : new Array(data_size),
       cov         : new Array(data_size),
       title       : new Array(data_size),
       state       : new Array(data_size), //a non negative integer
       
       state_labels : function (tile_idx){
         return ["State 1","State 2","State 3","State 4","State 5","State 6","State 7"];
       },
       state_reached_at : function (tile_idx){
         return [undefined,undefined,undefined,undefined,undefined,undefined,undefined];
       }       
     },
     ordering    : new Array(data_size), // pos => tile index
     visibility  : new Array(data_size),
     compute_ordering  : function () {
      for(let i = 0; i != THIS.ordering.length;++i)
       THIS.ordering[i] = i;
     },
     compute_visibility  : function () {
      for(let i = 0; i != THIS.visibility.length;++i)
       THIS.visibility[i] = true;
     },
     get_tile_at_row : function(row,cols,col){
       let r = -1;
       for(let i = 0; i < THIS.ordering.length; ++i){
         if (!THIS.visibility[THIS.ordering[i]]) continue;
         if (THIS.info.status[[THIS.ordering[i]]] != col) continue;         
         ++r;
         if (r == row) return i;
       }
       return undefined;     
     }
  };
  let data = THIS;
  for(let i = 0; i != data_size; ++i){
   data.info.state[i] = Math.floor(Math.random()*data.info.state_labels(i).length);
   data.info.status[i] = [TILE_STATUS_OK,TILE_STATUS_ERROR,TILE_STATUS_WARN][Math.floor(Math.random() * 3)];
   data.info.title[i]  = `market ${i+1}`;
   data.info.cov[i]    = Math.random();
   if (data.info.cov[i] >= 0.75){
    data.info.cov[i] = 1.0;
    data.info.status[i] = TILE_STATUS_DONE;
   }
  }
  THIS.compute_ordering();
  THIS.compute_visibility();

  return data;
 }
 
</script>

<script>
 let tiles = undefined;

 function create_tiles_deck(
             parentWidget,
             dataModel,
             style_info,
             info_box) {

  let data_size = dataModel.getSize();
  let idx2sm = {};

  let THIS = {
     cache             : {state_labels:{}},
     stateLabels       : dataModel.getStateLabels(),
     filters           : [],
     permutations      : [],
     size              : data_size,
     sm2idx            : [],
     enter_times       : {},
     exit_times        : {},
     tiles_widget      : null,
     up_since          : dataModel.getUpTime(),
     info              : {
       active      : new Array(data_size),
       status      : new Array(data_size),
       cov         : new Array(data_size),
       title       : new Array(data_size),
       state       : new Array(data_size), //a non negative integer
       state_labels : function (tile_idx){
         return THIS.stateLabels;
       },
       enter_time : function (tile_idx,state){
        return dataModel.getEnterTime(tile_idx,state);
       },
       exit_time : function (tile_idx,state){
        return dataModel.getExitTime(tile_idx,state);
       },       
       enter_times : function (tile_idx){
        return dataModel.getEnterTimes(tile_idx);
       },
       exit_times : function (tile_idx){
        return dataModel.getExitTimes(tile_idx);
       }
     },
     ordering    : new Array(data_size), // pos => tile index
     visibility  : new Array(data_size),
     compute_ordering  : function () {
      for(let i = 0; i != THIS.ordering.length;++i)
       THIS.ordering[i] = i;
     },
     compute_visibility  : function () {
      for(let i = 0; i != THIS.visibility.length;++i)
       THIS.visibility[i] = true;
     },
     get_tile_at_row : function(row,cols,col){
       let r = -1;
       for(let i = 0; i < THIS.ordering.length; ++i){
         if (!THIS.visibility[THIS.ordering[i]]) continue;
         if (THIS.info.status[[THIS.ordering[i]]] != col) continue;         
         ++r;
         if (r == row) return i;
       }
       return undefined;     
     },
     get_tiles_with_status: function (status_wanted){
       let r = [];
       for(let i = 0; i < THIS.ordering.length; ++i){
        if (!THIS.visibility[THIS.ordering[i]]) continue;
        if (THIS.info.status[[THIS.ordering[i]]] != status_wanted) continue;
        r.push(THIS.ordering[i]);
       }
       return r;
     },
     insert_entity: function (tile_idx,elem_data){
       THIS.tiles_widget.insert_entity(tile_idx,elem_data);
     },
     remove_entity:function(Index){
      THIS.tiles_widget.remove_entity(Index);
     },
     setActive:function(idx,b){
      THIS.tiles_widget.set_active(idx,b);
     },
     apply_filter:function(f){
      THIS.tiles_widget.apply_filter(f);
     }
  };

  let data = THIS;
  for(let i = 0; i    != data_size; ++i){
   data.info.state[i]  = dataModel.getState(i);
   data.info.status[i] = dataModel.getStatus(i);
   data.info.title[i]  = dataModel.getTitle(i);
   data.info.cov[i]    = dataModel.getCoverage(i);
   data.info.active[i] = true;
  }
  data.tile2states = dataModel.getTile2StatesMapping();
  data.tile2_visited_states = dataModel.getState2VisitedStates();
  data.state2root = dataModel.getState2RootMapping();
  data.state2label = dataModel.getState2LabelMapping();
  
  /*for(let i = 0; i < msg.labeled_states.length;++i){
    let label = msg.labeled_states[i];
    for(++i;i < msg.labeled_states.length;++i){
      if (typeof msg.labeled_states[i] === "string") break;
      data.state2label[msg.labeled_states[i]] = label;
    }
    if(i < msg.labeled_states.length) --i;
  }
  for(let i = 0; i != msg.root2childstates.length;++i){
   let root = msg.root2childstates[i];
   data.tile2_visited_states[root] = [];
   data.state2root[root] = root;
   let v = [];
   for(++i; i != msg.root2childstates.length;++i){
     if (msg.root2childstates[i]==0) break;
     data.state2root[msg.root2childstates[i]] = root;
     if(data.state2label[msg.root2childstates[i]] == undefined) continue;
     v.push(msg.root2childstates[i]);     
   }
   data.tile2states[root] = v;
  }
  if (msg.exec_context_start_utc != undefined){
    data.up_since = msg.exec_context_start_utc;
  }*/
  //update_states(msg,data,sm2idx);
  //update_timings(msg,data,sm2idx);

  THIS.compute_ordering();
  THIS.compute_visibility();
  if (style_info == null)
   THIS.tiles_widget = ceps_tiles_component(
    parentWidget,
    data,
    {tile_width:300}
   );
  else {
    if (style_info["tile_width"] == null) style_info["tile_width"]=300;
    THIS.tiles_widget = ceps_tiles_component(
    parentWidget,
    data,
    style_info,
    info_box
   );
  }
  return THIS;
}

function update_timings(msg,data,sm2idx,f){
  function read_timings(v,o){
    for(let i = 0; i != v.length && i + 3 < v.length;++i){
     let state = v[i];
     let secs_since_uptime = v[i+1];
     let msecs_since_uptime = v[i+2];
     let microsecs_since_uptime = v[i+3];
     o[state] = {secs_since_uptime:secs_since_uptime,msecs_since_uptime:msecs_since_uptime,microsecs_since_uptime:microsecs_since_uptime};
     i += 3;
    }
  };
  read_timings(msg.entering_times,data.enter_times);
  read_timings(msg.exiting_times,data.exit_times);  
}

function update_states(msg,data,sm2idx,f){
  for(let i = 0; i < msg.covered_states.length;++i){
    if (data.state2root[msg.covered_states[i]] == undefined) {
      continue;
    }
    let v = data.tile2_visited_states[data.state2root[msg.covered_states[i]]];
    if (v == undefined) {v = data.tile2_visited_states[data.state2root[msg.covered_states[i]]] = [];}
    v.push(msg.covered_states[i]);
  }
  for (let root in data.tile2states){
    let tile = sm2idx[root];
    let states = data.tile2states[root];
    let i = 0;
    let covered = data.tile2_visited_states[root];
    for(; i != states.length;++i){
      let found = false;
      for(let j = 0;j != covered.length;++j ){
        if (states[i] == covered[j]){
          found = true;
          break;
        }
      }
      if(!found) break;
    }
    if (i > 0) --i;
    if (f != undefined) f(tile,i);
    else data.info.state[tile] = i;
  }
}

let TimeLineWidget = function (parent, 
                               data, 
                               style_info) {
  let THIS = {
   groupedEntities : [],
   on_click : null,
   dom_cache : null,
   setActive(groupIndex,idx,b){
    THIS.groupedEntities[groupIndex].tiles.setActive(idx,b);
   },
   applyFilter(f){
     for(let i = 0; i != THIS.groupedEntities.length;++i ){
       if (THIS.groupedEntities[i].entities.length == 0) continue;
       THIS.groupedEntities[i].tiles.apply_filter(f);
     }
   },
   create   : function(){
    let entities_raw = data.getTopLevelEntities("rollout","false");
    let es = THIS.extractEntities(entities_raw);

    let t1 = Math.floor((Date.now() / 1000));
    let aDay = 24*3600;
    let today = Math.floor(t1 / (aDay)) * aDay +1;
    let tomorrow = today + aDay;
    let overmorrow = today + 2*aDay;
    let yesterday = today - aDay ;
    let ereyesterday = today - 2*aDay;

    let grouped_es = THIS.groupEntities(
      [
        {
          visible  : false,
          time     : ereyesterday,
          title    : (new Date(ereyesterday*1000)).toDateString() + " and older",
          entities : [],
        },
        {
          visible  : true,
          time     : yesterday,
          title    : "Yesterday <small>("+(new Date(yesterday*1000)).toDateString()+")</small>",
          entities : [],
        },
        {
          visible  : true,
          time     : today,
          title    : "Today <small>("+(new Date(today*1000)).toDateString()+")</small>",
          entities : []
        },
        {
          visible  : true,
          time     : tomorrow,
          title    : "Tomorrow <small>("+(new Date(tomorrow*1000)).toDateString()+")</small>",
          entities : []
        },
        {
          visible  : false,
          time     : overmorrow,
          title    : (new Date(overmorrow*1000)).toDateString() + " and younger",
          entities : []
        }          
      ],
      es
      );
    THIS.groupedEntities = grouped_es;
   },
   extractAttributes: function (e){
     let r = {
       coverage : null,
       health: null,
       title : e["name"]
     }
     if (e.children == null) return r;
     for(let i = 0; i != e.children.length;++i){
        if (e.children[i]["class"] != "attribute") 
          continue;
        r[e.children[i]["name"]] = e.children[i]["value"];

        /*  
        if (e.children[i]["name"]=="coverage" )
          r.cov = e.children[i]["value"];
        else if (e.children[i]["name"]=="health" )
          r.health = e.children[i]["value"];*/
      }
     return r;
   },
   translateHealthToTileStatus: function (health){
      if (health == null) return TILE_STATUS_INACTIVE;
      return { 
            "ok":TILE_STATUS_OK,
            "complete":TILE_STATUS_DONE,
            "failed":TILE_STATUS_ERROR,
            "failure":TILE_STATUS_ERROR,
            "fatal":TILE_STATUS_ERROR,
            "critical":TILE_STATUS_WARN,
            "n/a":TILE_STATUS_INACTIVE
        } [health];       
   },

   mergeAttributes:function(e_new,e_orig){
     if (e_new.children == null) return;
     for(let i = 0;i != e_new.children.length;++i){
       let a = e_new.children[i];       
       if (a["class"] == null || a["class"] != "attribute") continue;
       //try to find attribute in e_orig
       let found = false;
       for(let j = 0; j != e_orig.children.length;++j){
         let ao = e_orig.children[j];
         if (ao["id"] == null) continue;
         if (ao["id"] != a["id"]) continue;
         if (a["deleted"] == "true") ao["value"] = null;
         else ao["value"] = a["value"];
         found = true; break;
       } 
       if (!found && a["deleted"] != "true"){
         e_orig.children.push(a);
       }
     }
   },

   updateEntity : function (groupIdx, entityIdx, new_data) {
      e_orig = THIS.groupedEntities[groupIdx]
                   .entities[entityIdx];
      THIS.mergeAttributes(new_data,e_orig.raw);
      tiles = THIS.groupedEntities[groupIdx]["tiles"];
      let attributes = THIS.extractAttributes(new_data);
      if (attributes.coverage != null)
       tiles.tiles_widget.set_coverage(entityIdx,attributes.coverage);
      if (attributes.health != null)
       tiles.tiles_widget.set_status(
         entityIdx,
         THIS.translateHealthToTileStatus(attributes.health)
       );
      if (attributes.title != tiles.tiles_widget.data.info.title[entityIdx])
        tiles.tiles_widget.set_title(entityIdx,new_data["name"]);
       tiles.tiles_widget.data.up_since = attributes.start_time_unix_time;
      if (attributes.processing_status != null)
        THIS.setActive(groupIdx,entityIdx,true);
      if(attributes.scheduled_time_unix_time != null)
       e_orig.time = attributes.scheduled_time_unix_time;
   },
   deleteEntity: function(groupIndex,Index){
    THIS.groupedEntities[groupIndex].entities.splice(Index,1);
    THIS.groupedEntities[groupIndex]["tiles"].remove_entity(Index);
   },
   computeGroupIndex : function(groups,e){
     let e_time = e.time;
     for(let grp = 0;grp + 1 < groups.length;++grp){
       if (e_time < groups[grp+1].time) return grp;
     }
     return groups.length - 1;
   },
   update : function(changed_entities){
     let g = 0;
     let j = 0;
     let processed_ids = new Map;
     for(let i = 0; i != changed_entities.length;++i){
       let e = changed_entities[i];
       let e_orig = null;
       let tiles = null;
       let found = false;
       let deleted = false;
       for(g = 0; g != THIS.groupedEntities.length;++g)
       {
        for(j = 0; j != THIS.groupedEntities[g].entities.length;++j){
          if(THIS.groupedEntities[g].entities[j].id != e.id) continue;
          if (processed_ids[e.id]) continue;
          if (e.deleted != "true"){
           THIS.updateEntity(g,j,e);
           let grp_idx_after_update = 
            THIS.computeGroupIndex(THIS.groupedEntities,THIS.groupedEntities[g].entities[j]);
           if (grp_idx_after_update != g){
            processed_ids[e.id] = true;
             let entity = THIS.groupedEntities[g].entities[j];
             let state = THIS.groupedEntities[g].tiles.tiles_widget.data.info.state[j];
             let status = THIS.groupedEntities[g].tiles.tiles_widget.data.info.status[j];
             let cov = THIS.groupedEntities[g].tiles.tiles_widget.data.info.cov[j];
             let title = THIS.groupedEntities[g].tiles.tiles_widget.data.info.title[j];
             let visibility = THIS.groupedEntities[g].tiles.tiles_widget.data.visibility[j];
             THIS.deleteEntity(g,j);
             let indices = THIS.insertIntoGroupedEntities(THIS.groupedEntities,entity);
             let elem_data = {
             state : 0,
              status: status,
              title : title,
              cov   : cov
             }
             THIS.groupedEntities[indices.groupIndex]["tiles"].insert_entity(indices.idx,elem_data);             
            }
          }
          else deleted = true;
          found = true;
          break;
        }
        if (!found) continue;
        break;
       }
       if (found && deleted){
         THIS.deleteEntity(g,j);
       } else if (!found && e["deleted"]!="true" && processed_ids[e.id] == null){
         //CASE: New Entity
         let v = THIS.extractEntities([e]);
         if (v.length == 0) continue;
         e = v[0];
         let indices = THIS.insertIntoGroupedEntities(THIS.groupedEntities,e);
         let attrs = THIS.extractAttributes(e.raw);
         let tile_status = THIS.translateHealthToTileStatus(attrs.health);
         //let cov = 0.0;
         //if (attrs.cov != null) cov = attrs.cov;
         let elem_data = {
             state : 0,
             status:tile_status,
             title : attrs.title,
             cov   : attrs.coverage
         }
         THIS.groupedEntities[indices.groupIndex]["tiles"].insert_entity(indices.idx,elem_data);
       }
     }
   },
   insertIntoGroupedEntities : function (eg,e){
     let curGroup = 0;
     for(;curGroup + 1 < eg.length;++curGroup){
       if (eg[curGroup+1].time > e.time) break;
     } 
     let idx = 0;
     for(;idx < eg[curGroup].entities.length;++idx)
     {
       if (eg[curGroup].entities[idx].time > e.time) break;
     }
     if (idx == eg[curGroup].entities.length ) eg[curGroup].entities.push(e);
     else eg[curGroup].entities.splice(idx,0,e);
   
     return{
       groupIndex:curGroup,
       idx:idx
     };
   },
   buildDom : function(){
     THIS.dom_cache = [];
     let content = document.createElement("div");
     for(let i = 0; i != THIS.groupedEntities.length;++i){
       let dom_rep;
       THIS.dom_cache.push(
        dom_rep = {
           checkbox : null,
           body     : null
         }
       );
       let current_grp_index = i;
       let g = THIS.groupedEntities[i];
       if (g.entities.length == 0) continue;
       let header = document.createElement("div");
       let body = document.createElement("div");
       header.setAttribute("style",
       `border-bottom: 2px solid;margin:4px;padding:2px;`);
       let hh = document.createElement("div");
       //let title = document.crete.createTextNode(g.title);
       
       hh.innerHTML = `<h4>${g.title}</h4>`;//Child(title);
       
       let checkbox = dom_rep.check_box = document.createElement("div");
       checkbox.setAttribute(
         "style",
         `float:left;margin-top:5px;
         `
       );
       checkbox.setAttribute("class","rollaut_timeline_checkbox");
       if (g.visible){
         checkbox.innerHTML = `<i class="material-icons md-30">check_box</i>`;
       }
       else {
         body.setAttribute("style","display:none;");
         checkbox.innerHTML = `<i class="material-icons md-18">check_box_outline_blank</i>`;
       }


       header.appendChild(checkbox);
       header.appendChild(hh);
       content.appendChild(header);
       content.appendChild(body);
       let raw_data = [];
       for(let j = 0; j != g.entities.length;++j){
         raw_data.push(g.entities[j].raw);
       }
       dom_rep.body = body;
       g["tiles"] = create_tiles_deck(body, 
         /*Data Model*/{
           getSize : function () {return raw_data.length;},
           getTitle : function (idx) {return raw_data[idx]["name"];},
           getState : function(idx) {return 0;},
           getStatus: function(idx) { 
             return THIS.translateHealthToTileStatus(THIS.extractAttributes(raw_data[idx]).health);           
           },
           getCoverage: function(idx) { 
             return THIS.extractAttributes(raw_data[idx]).coverage;           
           },
           getTile2StatesMapping  : function() { return {}; },
           getState2VisitedStates : function() { return {}; },
           getState2RootMapping   : function() { return {}; },
           getState2LabelMapping  : function() { return {}; },
           getStateLabels         : function() { return []; },
           getEnterTime           : function(idx,state) { return 0; },
           getExitTime            : function(idx,state) { return 0; },
           getUpTime              : function() {return null;},
           getEnterTimes          : function(idx) {return [];},
           getExitTimes           : function(idx) {return [];}
        }
       );
       g["tiles"]["tiles_widget"].register_click_tile_handler(
         function (index,data){
          if (THIS.on_click != null){
           data["entity"] = THIS.groupedEntities[i].entities[index];
           data["attributes"] = THIS.extractAttributes(THIS.groupedEntities[i].entities[index].raw);
           THIS.on_click(index,data,current_grp_index);
          }
         }
       );
       checkbox.addEventListener("click",function (ev){
         g.visible = !g.visible;
         if (g.visible){
          body.setAttribute("style","display:block;");
          checkbox.innerHTML = `<i class="material-icons md-30">check_box</i>`;
         } else {
          body.setAttribute("style","display:none;");
          checkbox.innerHTML = `<i class="material-icons md-18">check_box_outline_blank</i>`;
        }                 
       });
     }
     parent.appendChild(content);
   },
   extractEntities: function (rawData){
     let r = [];
     for (let i = 0; i != rawData.length;++i){
       r.push(
         {
           raw: rawData[i],
           id: parseInt(rawData[i]["id"],10),
           time: data.readAttr("scheduled_time_unix_time", rawData[i])
         }
       );       
     }     
     return r.sort(function (lhs,rhs){ return lhs.time - rhs.time; });
   },
   groupEntities: function(groups,sorted_entities){
     let cur_group = 0;
     let ng = groups.length;
     for(let i = 0; i < sorted_entities.length;++i){
       let e = sorted_entities[i];
       if (cur_group + 1 < ng && e.time >= groups[cur_group+1].time)
       {
         for(;cur_group < ng;++cur_group){
          if( e.time >= groups[cur_group].time)
          {
            if (cur_group+1 == ng) break;
            if (groups[cur_group+1].time > e.time ) break;
          } else break;
         }
       }
       groups[cur_group].entities.push(e);
     }
     return groups;
   }
 };
 THIS.create();
 THIS.buildDom();
 return THIS;
}
</script>



<script>
  
  function diff_merge(db,diff){
  
  }

  let RollAutKafkaeskAPI = function (url,on_db_changed){
    THIS = {
      dbviews : [],
      main_socket : undefined,
      connected   : false,
      on_connect_handler : [],
      on_close_handler   : [],

      //
      //
      //  {
      //    loc: Location
      //    db : Database
      //    getTopLevelEntities:function (type,deleted)
      //  }
      //
      //
      create_db_view: function(loc){
        let r = {
          loc: loc,
          db : null,
          merge: function(diff){
            diff_merge(diff,THIS.db);
            return diff;
          },
          readAttr:function(attr,node){
            if (attr == null || node == null) return null;
            let v = node["children"];
            if (v == undefined ) return null;
            for(let i = 0; i != v.length;++i){
              if (v[i]["class"] != "attribute")
               continue;
              if (v[i]["name"] != attr) 
               continue;
              return v[i]["value"];
            }
            return null;
          },
          getTopLevelEntities:function (type,deleted){
            let r = [];
            for(let i = 0; i != this.db.length;++i){
              let v = this.db[i];  
              if (v["class"] == "entry" && v["deleted"] == deleted){
                for(let i = 0; i != v.children.length;++i){
                  let a = v.children[i];
                  if (a["class"] != "attribute" || a["name"] != "entity") continue;
                  if (a["value"] != type) continue;
                  r.push(v); break;
                }
              }
            }
            return r;
          }
        }
        THIS.dbviews.push(r);
        return r;
      },
      get_db_view: function (loc){
        for(let i = 0; i != THIS.dbviews.length;++i){
          if (THIS.dbviews[i]["loc"] == loc) return THIS.dbviews[i];
        }
        return null;
      },
      unregister_handler   : function (what,f){
        let v = undefined;
        if ("open" == what) v = THIS.on_connect_handler;
        else if ("close" == what) v = THIS.on_close_handler;
        for(let i = 0; i != v.length;++i) if (v[i] == f) {v[i]=undefined;break;}
      },
      register_handler   : function (what,f){
        let v = undefined;
        if ("open" == what) v = THIS.on_connect_handler;
        else if ("close" == what) v = THIS.on_close_handler;
        let slot = -1;
        if (v.length){
          for(let i = 0; i != v.length;++i) if (v[i] == undefined) {slot=i;break;}
        }
        if (slot != -1) v[slot] = f;
        else v.push(f);
      },
      pending_subscribers : { }, //topic -> list of handlers
      topic_subscribers   : { }, //channel -> list of handlers
      subscribe   : function(loc,force) {
        if (force == null) force = false;
        if (THIS.main_socket == null) return false;
        if (THIS.get_db_view(loc) != null && !force){
           return true;
        }
        if (THIS.main_socket.readyState != 1){
          let h = function(){
            THIS.main_socket.removeEventListener("open",h);
            THIS.main_socket.send(JSON.stringify({what:"command",name:"subscribe",params:[loc]}));
          };
          THIS.main_socket.addEventListener("open",h);
          return true;
        }         
        THIS.main_socket.send(JSON.stringify({what:"command",name:"subscribe",params:[loc]}));
        return true;
      },
      connect     : function(){
            THIS.connected = false;
            THIS.main_socket = new WebSocket("ws://"+url);
            THIS.main_socket.addEventListener("open", THIS.on_ws_initial_connect);
            THIS.main_socket.addEventListener("close", THIS.on_ws_close);
            THIS.main_socket.addEventListener("error", THIS.on_ws_error);
            THIS.main_socket.addEventListener("message",THIS.on_message);
      },
      on_ws_initial_connect: function (ev) {
            THIS.connected = true;
            for(let i = 0; i!=THIS.on_connect_handler.length;++i)
             if (THIS.on_connect_handler[i]!=undefined) THIS.on_connect_handler[i](THIS,THIS.on_connect_handler[i]);
      },
      on_ws_close: function (ev) {
            let connection_status = THIS.connected;
            THIS.connected = false;
            for(let i = 0; i!=THIS.on_close_handler.length;++i)
             if (THIS.on_close_handler[i]!=undefined) THIS.on_close_handler[i](THIS,connection_status,THIS.on_connect_handler[i]);
      },
      on_ws_error: function (ev) {
            
      },
      on_message: function (ev){
        let msg = JSON.parse(ev.data);
        console.log(msg);
        if (msg.class == "diff"){
          let db_view = THIS.get_db_view(msg.watched_location);
          if (db_view == null){
            db_view = THIS.create_db_view(msg.watched_location);
          }
          if (db_view.db == null){
            db_view.db = msg.children[0].children;
            on_db_changed(db_view,null);
            return;
          } else {
            //MERGE
            if (msg.children.length == 0) return; //Nothing to do
            let changed_items = db_view.merge(msg.children[0].children);
            on_db_changed(db_view,changed_items);
          }
        }
      }
    };
    return THIS;
  }
  
</script>


<script>


 
 window.onload = () => {

 staccatoAPI = data_channel = 
  RollAutKafkaeskAPI(/*window.location.hostname+":11001"*/window.location.hostname+":3333",
  function (dbView,changed_items){
    if (changed_items == null){
      let container = document.getElementById("info_tiles");
      for(;container.hasChildNodes();)container.removeChild(container.firstChild);
      timeLineWidget = TimeLineWidget(container,dbView);
      timeLineWidget.on_click = function (index,data,groupIndex){
        build_rollout_overview_dlg("dlg_rollout_details",groupIndex,index,data);
        setTimeout( function () {$("#dlg_rollout_details").modal();},200);
      };
    } else {
      //Update
      timeLineWidget.update(changed_items);      
    }
  }
  );
 data_channel.connect();
 data_channel.subscribe("rollouts/scheduled");

 data_channel.register_handler("open",
    (channel) =>{
      let connection_info = document.getElementById("nav_info_connection");
      if(connection_info == undefined) return;
      connection_info.setAttribute("class","badge badge-success");
      connection_info.innerHTML =
        `<span>Connected</span>`
      ;
    }
 );

 data_channel.register_handler("close",
    (channel,connection_status) =>{
      setTimeout(()=>{
        data_channel.connect();
        data_channel.subscribe("rollouts/scheduled",true);
      },1000);
      if (!connection_status) return;
      let connection_info = document.getElementById("nav_info_connection");
      if(connection_info == undefined) return;
      connection_info.setAttribute("class","badge badge-danger");
      connection_info.innerHTML =
        `<div style="float:left;margin:2px;" class="rollaut_connection_loader"></div><span style="vertical-align: sub;">Not Connected</span>`
      ;          
    }
  );



return;  

  //ceps_core_channel = 
  // cepS_API(/*window.location.hostname+":11001"*/window.location.hostname+":");
  ceps_core_channel.register_handler("open",
    (channel) =>{
      let connection_info = document.getElementById("nav_info_connection");
      if(connection_info == undefined) return;
      connection_info.setAttribute("class","badge badge-success");
      connection_info.innerHTML =
        `<span>Connected</span>`
      ;
    }
  );

  ceps_core_channel.register_handler("open",
    (channel,handler) => {
      let map_tile_status2cat_idx=undefined;
      let sm2idx = {};
      let connection_info = document.getElementById("nav_info_connection");
      channel.subscribe("COVERAGE", 
       (msg)=>{
        function update_status(msg){
          let v = msg.category_changes;
          if (v != undefined)
           for(let i = 0; i != v.length;++i){
             let tile_idx = sm2idx[v[i]];
             let cat_idx = v[i+1];
             if (cat_idx == 0) tiles.set_status(tile_idx,TILE_STATUS_OK);
             else if (cat_idx & map_tile_status2cat_idx[TILE_STATUS_ERROR]) tiles.set_status(tile_idx,TILE_STATUS_ERROR);
             else if (cat_idx & map_tile_status2cat_idx[TILE_STATUS_WARN]) tiles.set_status(tile_idx,TILE_STATUS_WARN);
             else if (cat_idx & map_tile_status2cat_idx[TILE_STATUS_DONE]) tiles.set_status(tile_idx,TILE_STATUS_DONE);
             ++i;
           }
        }
         if (msg.what != undefined && msg.what == "init"){
          if(msg.category_mapping!=undefined){
            map_tile_status2cat_idx = {};
            for(let i = 0; i != msg.category_mapping.length; ++i){
              let cat_name = msg.category_mapping[i];
              let idx = 1 << msg.category_mapping[i+1];
              if (cat_name == "FailState") map_tile_status2cat_idx[TILE_STATUS_ERROR] = idx ;
              else if (cat_name == "WarnState") map_tile_status2cat_idx[TILE_STATUS_WARN] = idx;
              else if (cat_name == "DoneState") map_tile_status2cat_idx[TILE_STATUS_DONE] = idx;
              ++i;
            }
          }
          if (connection_info != undefined) setTimeout( () => {
            connection_info.setAttribute("class","badge badge-success");
            connection_info.innerHTML =
            `<span>Ok<br/>
             Workflow has <b>${msg.total_of_states}</b> states<br/>
             and <b>${msg.total_of_transitions}</b> transitions</span>`;
          },2000);
          for(let i = 0; i != msg.toplevel_sms.length;++i){
            sm2idx[msg.toplevel_sms[i]] = i;
          }
          create_tiles_deck(msg,sm2idx);
          update_status(msg);
         } else if (msg.what != undefined && msg.what == "update"){
          for(let i = 0; i != msg.toplevel_sms.length;++i){
            tiles.set_coverage(sm2idx[msg.toplevel_sms[i]],msg.toplevel_sms_transition_coverage[i]);
          }
          
          update_timings(msg,tiles.data,sm2idx);
          update_states(msg,tiles.data,sm2idx,tiles.set_state);
          update_status(msg);
         }        
       }
      );      
      if(connection_info == undefined) return;
      connection_info.setAttribute("class","badge badge-info");
      connection_info.innerHTML =
        `<div style="float:left;margin:2px;" class="rollaut_connection_loader"></div><span style="vertical-align: sub;">Fetching Data</span>`
      ;          
    }
  );
  
  ceps_core_channel.register_handler("close",
    (channel,connection_status) =>{
      setTimeout(()=>{ceps_core_channel.connect();},1000);
      if (!connection_status) return;
      let connection_info = document.getElementById("nav_info_connection");
      if(connection_info == undefined) return;
      connection_info.setAttribute("class","badge badge-danger");
      connection_info.innerHTML =
        `<div style="float:left;margin:2px;" class="rollaut_connection_loader"></div><span style="vertical-align: sub;">Not Connected</span>`
      ;          
    }
  );

  ceps_core_channel.connect();
  return;


 }; 

</script>
</html>
