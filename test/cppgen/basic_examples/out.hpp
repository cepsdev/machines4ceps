/* out.hpp 
   CREATED Sun Jun 19 14:37:32 2016

   GENERATED BY the sm4ceps C++ Generator VERSION 0.3 (c) Tomas Prerovsky <tomas.prerovsky@gmail.com>, ALL RIGHTS RESERVED. 
   Requires C++1y compatible compiler (use --std=c++11 for g++) 
   BASED ON cepS VERSION 1.1 (May 28 2016) BUILT WITH GCC 5.2.1 20151010 on GNU/LINUX 64BIT (C) BY THE AUTHORS OF ceps (ceps is hosted at github: https://github.com/cepsdev/ceps.git) 
   THIS IS A GENERATED FILE. DO NOT MODIFY.
*/




#include<iostream>
#include<string>
#include<algorithm>
#include<map>
#include<vector>
#include<cstdlib>
#include"user_defined.hpp"

namespace systemstates{


struct Variant{
  double dv_ = 0.0;
  int iv_ = 0;
  std::string sv_ ="";
  enum {Int,Double,String,Undefined} what_ = Undefined;
  Variant (double v):dv_{v},what_{Double}{}
  Variant (int v):iv_{v},what_{Int}{}
  Variant (std::string v):sv_{v},what_{String}{}
  Variant() = default;

 };

 std::ostream& operator << (std::ostream& o, Variant const & v){
  return o;
 }

 template<typename T> class State{
   T v_;
   bool changed_ = true;
   bool default_constructed_ = true;
 public:
   State() = default; 
   State(T const & v):v_{v},default_constructed_{false} {}
   State& operator = (State const & rhs){
     if (!changed_ && !default_constructed_) changed_ = v_ != rhs.v_;
     else if (default_constructed_) {default_constructed_ = false;changed_ = true;}
     v_ = rhs.v_;
     return *this;
   }
   State& operator = (T const & rhs){
     if (!changed_ && !default_constructed_) changed_ = v_ != rhs;
     else if (default_constructed_) {changed_ = true; default_constructed_=false;}
     v_ = rhs;
     return *this;
   }
   bool changed() {auto t = changed_;changed_=false;return t;}

   T& value() {return v_;}
   T value() const {return v_;}
 
  };

 std::ostream& operator << (std::ostream& o, State<int> & v){
  o << v.value();
  return o;
 }

 std::ostream& operator << (std::ostream& o, State<double> & v){
  o << v.value();
  return o;
 }

 double abs(Variant const &v){if (v.what_ == Variant::Double) return std::abs(v.dv_); return std::abs(v.iv_); }
 

 bool operator == (Variant const & lhs, std::string const & rhs) {return lhs.sv_ == rhs;}
 bool operator == (std::string const & lhs, Variant const & rhs) {return rhs.sv_ == lhs;}
 bool operator == (Variant const & lhs, int const & rhs) {return lhs.iv_ == rhs;}
 bool operator == (int const & lhs, Variant const & rhs) {return rhs.iv_ == lhs;}
 bool operator == (Variant const & lhs, double const & rhs) {return lhs.dv_ == rhs;}
 bool operator == (double const & lhs, Variant const & rhs) {return rhs.dv_ == lhs;}

 bool operator != (Variant const & lhs, std::string const & rhs) {return lhs.sv_ != rhs;}
 bool operator != (std::string const & lhs, Variant const & rhs) {return rhs.sv_ != lhs;}
 bool operator != (Variant const & lhs, int const & rhs) {return lhs.iv_ != rhs;}
 bool operator != (int const & lhs, Variant const & rhs) {return rhs.iv_ != lhs;}
 bool operator != (Variant const & lhs, double const & rhs) {return lhs.dv_ != rhs;}
 bool operator != (double const & lhs, Variant const & rhs) {return rhs.dv_ != lhs;}

 bool operator > (Variant const & lhs, std::string const & rhs) {return lhs.sv_ > rhs;}
 bool operator > (std::string const & lhs, Variant const & rhs) {return rhs.sv_ > lhs;}
 bool operator > (Variant const & lhs, int const & rhs) {return lhs.iv_ > rhs;}
 bool operator > (int const & lhs, Variant const & rhs) {return rhs.iv_ > lhs;}
 bool operator > (Variant const & lhs, double const & rhs) {return lhs.dv_ > rhs;}
 bool operator > (double const & lhs, Variant const & rhs) {return rhs.dv_ > lhs;}

 bool operator >= (Variant const & lhs, std::string const & rhs) {return lhs.sv_ >= rhs;}
 bool operator >= (std::string const & lhs, Variant const & rhs) {return rhs.sv_ >= lhs;}
 bool operator >= (Variant const & lhs, int const & rhs) {return lhs.iv_ >= rhs;}
 bool operator >= (int const & lhs, Variant const & rhs) {return rhs.iv_ >= lhs;}
 bool operator >= (Variant const & lhs, double const & rhs) {return lhs.dv_ >= rhs;}
 bool operator >= (double const & lhs, Variant const & rhs) {return rhs.dv_ >= lhs;}

 bool operator < (Variant const & lhs, std::string const & rhs) {return lhs.sv_ < rhs;}
 bool operator < (std::string const & lhs, Variant const & rhs) {return rhs.sv_ < lhs;}
 bool operator < (Variant const & lhs, int const & rhs) {return lhs.iv_ < rhs;}
 bool operator < (int const & lhs, Variant const & rhs) {return rhs.iv_ < lhs;}
 bool operator < (Variant const & lhs, double const & rhs) {return lhs.dv_ < rhs;}
 bool operator < (double const & lhs, Variant const & rhs) {return rhs.dv_ < lhs;}

 bool operator <= (Variant const & lhs, std::string const & rhs) {return lhs.sv_ <= rhs;}
 bool operator <= (std::string const & lhs, Variant const & rhs) {return rhs.sv_ <= lhs;}
 bool operator <= (Variant const & lhs, int const & rhs) {return lhs.iv_ <= rhs;}
 bool operator <= (int const & lhs, Variant const & rhs) {return rhs.iv_ <= lhs;}
 bool operator <= (Variant const & lhs, double const & rhs) {return lhs.dv_ <= rhs;}
 bool operator <= (double const & lhs, Variant const & rhs) {return rhs.dv_ <= lhs;}

 State<int>& set_value(State<int>& lhs, Variant const & rhs){lhs.value() = rhs.iv_; return lhs;}
 State<int>& set_value(State<int>& lhs, int rhs){lhs.value() = rhs; return lhs;}
 State<double>& set_value(State<double>& lhs, double rhs){lhs.value() = rhs; return lhs;}
 State<std::string>& set_value(State<std::string>& lhs, std::string rhs){lhs.value() = rhs; return lhs;}

 void queue_event(std::string ev_name,std::initializer_list<Variant> vl = {});

struct ev{
  std::string name_;
  ev(std::string name):name_(name){}
};

struct id{
  std::string name_;
  id(std::string name):name_(name){}
};



}
namespace guards{

 using Guard = bool(*)();
 using Guard_impl = bool ();




}
namespace globfuncs{

 extern bool in_state(std::initializer_list<systemstates::id>);
 extern void start_timer(double,systemstates::ev);
 extern void start_timer(double,systemstates::ev,systemstates::id);
 extern void start_periodic_timer(double,systemstates::ev);
 extern void start_periodic_timer(double,systemstates::ev,systemstates::id);
 extern void stop_timer(systemstates::id);
 extern size_t argc();
 extern systemstates::Variant argv(size_t);
 extern bool send(systemstates::id,systemstates::id);

void S__action__OnA();

}
