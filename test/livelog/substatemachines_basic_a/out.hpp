/* out.hpp 
   CREATED Thu Sep 22 16:25:30 2016

   GENERATED BY THE sm4ceps C++ GENERATOR VERSION 0.80 (c) 2016 Tomas Prerovsky <tomas.prerovsky@gmail.com>, ALL RIGHTS RESERVED. 
   BASED ON cepS VERSION 1.1 (May 28 2016) BUILT WITH GCC 5.2.1 20151010 on GNU/LINUX 64BIT (C) BY THE AUTHORS OF ceps (ceps is hosted at github: https://github.com/cepsdev/ceps.git) 

   Input files:
      substatemachines_basic_a.ceps

   THIS IS A GENERATED FILE.

   *** DO NOT MODIFY. ***
*/



#ifndef INC_SM4CEPS_GEN_OUT_HPP
#define INC_SM4CEPS_GEN_OUT_HPP
#include <iostream>
#include <string>
#include <algorithm>
#include <map>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <sstream>
#include "core/include/state_machine_simulation_core_reg_fun.hpp"
#include "core/include/state_machine_simulation_core_plugin_interface.hpp"
#include "user_defined.hpp"

 static Ism4ceps_plugin_interface* smcore_interface; 

namespace systemstates{


 using sm4ceps_plugin_int::Variant;
 using sm4ceps_plugin_int::ev;
 using sm4ceps_plugin_int::id;

 template<typename T> class State{
   T v_;
   bool changed_ = false;
 public:
   State() = default; 
   State(T const & v) { v_ = v;}
   State& operator = (State const & rhs){
     changed_ = v_ != rhs.v_;
     v_ = rhs.v_;
     return *this;
   }
   State& operator = (T const & rhs){
     changed_ = v_ != rhs;
     v_ = rhs;
     return *this;
   }
   bool changed() {auto t = changed_;changed_=false;return t;}
   void set_changed(bool t){changed_=t;}
   T& value() {return v_;}
   T value() const {return v_;} 
  };

 std::ostream& operator << (std::ostream& o, State<int> & v);
 std::ostream& operator << (std::ostream& o, State<double> & v); 
 State<int>& set_value(State<int>& lhs, Variant const & rhs);
 State<int>& set_value(State<int>& lhs, int rhs);
 State<double>& set_value(State<double>& lhs, double rhs);
 State<double>& set_value(State<double>& lhs, Variant const & rhs);
 State<std::string>& set_value(State<std::string>& lhs, std::string rhs);



}
namespace guards{

 using Guard = bool(*)();
 using Guard_impl = bool ();




}
namespace globfuncs{

 extern bool in_state(std::initializer_list<sm4ceps_plugin_int::id>);
 extern void start_timer(double,sm4ceps_plugin_int::ev);
 extern void start_timer(double,sm4ceps_plugin_int::ev,sm4ceps_plugin_int::id);
 extern void start_periodic_timer(double,sm4ceps_plugin_int::ev);
 extern void start_periodic_timer(double,sm4ceps_plugin_int::ev,sm4ceps_plugin_int::id);
 extern void stop_timer(sm4ceps_plugin_int::id);
 void start_periodic_timer(double t,sm4ceps_plugin_int::Variant (*fp)(),sm4ceps_plugin_int::id id_);
 void start_periodic_timer(double t,sm4ceps_plugin_int::Variant (*fp)());
 size_t argc();
 sm4ceps_plugin_int::Variant argv(size_t);
 extern bool send(systemstates::id,systemstates::id);

void S1__action__t1();
void S1__action__t2();
void S1__action__t3();
void S1__action__t4();
void S1__action__on_enter();
void S1__action__on_exit();
void S1__S1a__action__t1();
void S1__S1a__action__t2();
void S1__S1a__action__t3();
void S1__S1a__action__t4();
void S1__S1a__action__t5();
void S1__S1a__action__on_enter();
void S1__S1a__action__on_exit();
void S1__S1a__S1aa__action__on_enter();
void S1__S1a__S1aa__action__on_exit();
void S1__S1a__S1ab__action__on_enter();
void S1__S1a__S1ab__action__on_exit();
void S1__S1a__S1ac__action__on_enter();
void S1__S1a__S1ac__action__on_exit();
void S2__action__on_enter();
void S2__action__on_exit();
void S3__action__a1();
void S4__action__a();

}
std::ostream& operator << (std::ostream& o, systemstates::Variant const & v);
#endif
