
kind DocgenStringPrintNoEscape;
DocgenStringPrintNoEscape docinfo_se;

macro insertion_sort_text{
    val ascending = hd(arglist);
    OblectamentaCodeLabel inner_loop_start, inner_loop_exit,outer_loop_start,outer_loop_exit,start,stop,inc_i;
    OblectamentaDataLabel zero,key,k,length,int_width,four,one,array, result, i, n;
    asm{
            ldi32(one);
            sti32(i); // i <- 1;
                        
        outer_loop_start;
            ldi32(length);
            ldi32(i);
            lti32;
                        
            bzeroi32(outer_loop_exit); // for (int i = 1; i < length; ++i)

            lea(array);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;
            sti32(key); // key <- array[i]

            ldi32(one);
            ldi32(i);
            subi32;
            sti32(k);

        inner_loop_start;
            ldi32(zero);
            ldi32(k);
            gteqi32;
            bzeroi32(inner_loop_exit);
                    
            lea(array);
            ldi32(k);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;
            ldi32(key);
            gteqi32;  // array[k] <= key
            if (ascending){
             bnzeroi32(inner_loop_exit);
            } else {
             bzeroi32(inner_loop_exit);
            }

            lea(array);
            ldi32(k);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;

            lea(array);
            ldi32(k);
            ldi32(one);
            addi32;
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            stsi32; // array[k+1] = array[k]
                    
            ldi32(one);
            ldi32(k);
            subi32;
            sti32(k);
            buc(inner_loop_start);
        inner_loop_exit;

            ldi32(key);
            lea(array);
            ldi32(k);
            ldi32(one);
            addi32;
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            stsi32; //array[k+1] = key

            ldi32(one);
            ldi32(i);
            addi32;
            sti32(i); // i <- i + 1
            buc(outer_loop_start);
        outer_loop_exit;                
        stop;                        
            halt;
    };
};

macro linear_search_text{
    OblectamentaCodeLabel start,loop,found,stop;
    OblectamentaDataLabel x,zero,int_width,one,array, result, i, n;
    asm{
            ldi32(zero);
            sti32(i);
        loop;
            ldi32(i);
            ldi32(n);
            gti32;
            bzeroi32(stop);
            lea(array);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;
            ldi32(x);
            eqi32;
            bnzeroi32(found);
            ldi32(one);
            ldi32(i);
            addi32;
            sti32(i);
            buc(loop);
        found;
            ldi32(i);
            sti32(result);
        stop;                        
            halt;
    };
};


Scenario{
    title{label __ title = "INSERTION-SORT (ASCENDING)";};

    OblectamentaCodeLabel inner_loop_start, inner_loop_exit,outer_loop_start,outer_loop_exit,start,stop,inc_i;
    OblectamentaDataLabel zero,key,k,length,int_width,four,one,array, result, i, n;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     10;9;8;7;6;5;4;3;2;1;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    i; 
                     0;
                    k;
                     0;
                    key;
                     0;
                     length; 10;
                    };
                text{
                    insertion_sort_text{1;};
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
        verdict{equality_test{ 
            {
                for(k : 0 .. 9){
                    the_vm.vm.data.content().at((k*4)+1 );the_vm.vm.data.content().at((k*4)+2);the_vm.vm.data.content().at((k*4)+3);the_vm.vm.data.content().at((k*4)+4);
                }           
            }
            {
                for(k:1 .. 10){
                    as_uint8(k);as_uint8(0);as_uint8(0);as_uint8(0);
                }
            }
        };};
    };
};

Scenario{
    title{label __ title = "INSERTION-SORT (DESCENDING)";};

    OblectamentaCodeLabel inner_loop_start, inner_loop_exit,outer_loop_start,outer_loop_exit,start,stop,inc_i;
    OblectamentaDataLabel zero,key,k,length,int_width,four,one,array, result, i, n;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     10;9;8;7;6;5;4;3;2;1;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    i; 
                     0;
                    k;
                     0;
                    key;
                     0;
                     length; 10;
                    };
                text{
                    insertion_sort_text{0;};
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
        verdict{equality_test{ 
            {
                for(k : 0 .. 9){
                    the_vm.vm.data.content().at((k*4)+1 );the_vm.vm.data.content().at((k*4)+2);the_vm.vm.data.content().at((k*4)+3);the_vm.vm.data.content().at((k*4)+4);
                }           
            }
            {
                for(k:1 .. 10){
                    as_uint8(10 - k + 1);as_uint8(0);as_uint8(0);as_uint8(0);
                }
            }
        };};
    };
};

Scenario{
    title{label __ title = "SUM-ARRAY";};

    OblectamentaCodeLabel start,loop,stop,inc_i;
    OblectamentaDataLabel zero,int_width,one,array, result, i, n;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    result; -1;
                    zero;0;
                    one;1;
                    int_width;4;
                    n;10;
                    array; 1;2;3;4;5;6;7;8;9;10;
                    i;0;
                };
                text{
                    asm{
                        ldi32(zero);
                        sti32(i);
                        ldi32(zero);
                        sti32(result);
                    loop;
                        ldi32(i);
                        ldi32(n);
                        gti32;
                        bzeroi32(stop);

                        lea(array);
                        ldi32(i);
                        ldi32(int_width);
                        muli32;
                        ui32toui64;
                        addi64;
                        ldsi32;
                        ldi32(result);
                        addi32;
                        sti32(result);
                        ldi32(i);
                        ldi32(one);
                        addi32;
                        sti32(i);
                        buc(loop);

                    stop;                        
                        halt;
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
        verdict{equality_test{ 
            {the_vm.vm.data.content().at(1);}
            {
                as_uint8(55);
            }
        };};
    };
};

Scenario{
    title{label __ title = "LNEAR-SEARCH";};

    OblectamentaDataLabel x,zero,int_width,one,array, result, i, n;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    result; -1;
                    x; 10;
                    zero;0;
                    one;1;
                    int_width;4;
                    n;10;
                    array; 1;2;3;4;5;6;7;8;9;10;
                    i;-1;
                };
                text{
                    linear_search_text{};
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
        verdict{equality_test{ 
            {the_vm.vm.data.content().at(1);}
            {
                as_uint8(9);
            }
        };};
    };
};

Scenario{
    title{label __ title = "BINARY-ADD";};

    OblectamentaDataLabel t, carry,c,a,b,x,zero,int_width,one,two,three,array, result, i, n;
    OblectamentaCodeLabel loop_next,loop,loop_exit, sum_zero, sum_one, sum_two, sum_three; 

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    c; 0;0;0;0;0; 
                    zero;0;
                    one;1;
                    two;2;
                    three;3;
                    int_width;4;
                    n;4;
                    a; 1;0;0;0;
                    b; 1;1;0;0;
                    i;-1;
                    carry;0;
                    t;-1;
                };
                text{
    asm{
            ldi32(zero);
            sti32(i);
            ldi32(zero);
            sti32(carry);
        loop;
            ldi32(i);
            ldi32(n);
            gti32;
            bzeroi32(loop_exit);
            
            lea(a);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;

            lea(b);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;

            ldsi32;

            addi32;
            ldi32(carry);
            addi32;
            sti32(t);
            ldi32(t);
            bnzeroi32(sum_one);            
        sum_zero;
            ldi32(zero);
            lea(c);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            stsi32;
            ldi32(zero);
            sti32(carry);

            buc(loop_next);
        sum_one;

            ldi32(t);
            ldi32(one);
            eqi32;
            bzeroi32(sum_two);

            ldi32(one);
            lea(c);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            stsi32;
            ldi32(zero);
            sti32(carry);
            buc(loop_next);
        sum_two;

            ldi32(t);
            ldi32(two);
            eqi32;
            bzeroi32(sum_three);

            ldi32(zero);
            lea(c);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            stsi32;

            ldi32(one);
            sti32(carry);
            buc(loop_next);
        sum_three;
            ldi32(one);
            lea(c);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            stsi32;

            ldi32(one);
            sti32(carry);
        loop_next;   

            ldi32(one);
            ldi32(i);
            addi32;
            sti32(i);
            buc(loop);
        loop_exit;
            ldi32(carry);
            lea(c);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            stsi32;

            halt;
    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
        verdict{equality_test{ 
            {for(i: 1 .. 9) { the_vm.vm.data.content().at(i);} }
            {
                as_uint8(0);as_uint8(0);as_uint8(0);as_uint8(0);as_uint8(0);as_uint8(0);as_uint8(0);as_uint8(0);as_uint8(1);
            }
        };};
    };
};

Scenario{
    title{label __ title = "SELECTION-SORT";};

    OblectamentaDataLabel r,int_width,k, a, n, i, current_min,current_min_idx, j, zero, one, two, three;
    OblectamentaCodeLabel loop_find_min_index_next,find_min_index_exit,loop_next,loop,loop_exit, find_min_index, stop, loop_find_min_index; 

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data
                {
                    a; 10;9;8;7;6;5;4;3;2;1;
                    c; 0;0;0;0;0; 
                    zero;0;
                    one;1;
                    two;2;
                    three;3;
                    int_width;4;
                    n;10;
                    i;-1;
                    k;-1;
                    carry;0;
                    t;-1;
                    j; -1;
                    current_min; -1;
                    current_min_idx; -1;
                    r; -1;
                };
                text{
    asm{
            ldi32(zero);
            sti32(i);
        loop;
            ldi32(i);
            //ldi32(one);
            ldi32(n);
            //subi32;
            gti32;
            bzeroi32(stop);
            ldi32(i);
            call(find_min_index);
            sti32(r);

            lea(a);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;
            sti32(t);

            lea(a);
            ldi32(r);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;
            lea(a);
            ldi32(i);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            stsi32;

            ldi32(t);
            lea(a);
            ldi32(r);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            stsi32; // swap a[i] and a[r]
          


            ldi32(i);
            ldi32(one);
            addi32;
            sti32(i);
            buc(loop);
        find_min_index;
            sti32(j);
            lea(a);
            ldi32(j);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;
            sti32(current_min);
            ldi32(j);
            sti32(current_min_idx);
            buc(loop_find_min_index_next);
        loop_find_min_index;
            ldi32(j);
            ldi32(n);
            gti32;
            bzeroi32(find_min_index_exit);

            lea(a);
            ldi32(j);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;
            ldi32(current_min);
            gti32;
            bzeroi32(loop_find_min_index_next);
            ldi32(j);
            sti32(current_min_idx);

            lea(a);
            ldi32(j);
            ldi32(int_width);
            muli32;
            ui32toui64;
            addi64;
            ldsi32;
            sti32(current_min);

        loop_find_min_index_next;
            ldi32(j);
            ldi32(one);
            addi32;
            sti32(j);
            buc(loop_find_min_index);
        find_min_index_exit;
           
            ldi32(current_min_idx);
            ret;
        stop;
            halt;
    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
        verdict{equality_test{ 
            {
                for(k : 0 .. 9){
                    the_vm.vm.data.content().at((k*4)+1 );the_vm.vm.data.content().at((k*4)+2);the_vm.vm.data.content().at((k*4)+3);the_vm.vm.data.content().at((k*4)+4);
                }           
            }
            {
                for(k:1 .. 10){
                    as_uint8(k);as_uint8(0);as_uint8(0);as_uint8(0);
                }
            }
        };};
    };
};

macro pushi32Var{
    val what = hd(arglist);
    ldi32(what);
    ldi64(SP-4);
    stsi32;
    ldi64(SP-4);
    sti64(SP);
};
macro pushAddr{
    val what = hd(arglist);
    lea(what);
    ldi64(SP-8);
    stsi64;
    ldi64(SP-8);
    sti64(SP);
};

macro func_prologue{

    ldi64(SP);
    ldi64(SP-8);
    stsi64;                            
    ldi64(SP-8);
    sti64(SP);         // push SP

    ldi64(FP);
    ldi64(SP-8);
    stsi64;                            
    ldi64(SP-8);
    sti64(SP);         // push FP

    ldi64(SP+16);
    sti64(FP);  // FP <- Original SP    

};

macro func_epilogue{
    
    ldi64(SP);            
    ldsi64;
    sti64(FP); // Restore FP
    ldi64(SP+8);
    sti64(SP);

    
    ldi64(SP);        
    ldsi64;
    sti64(SP); // restore SP
    ret;
};

macro merge_text{

     // MERGE(A,p,q,r), see p.36 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaCodeLabel Merge, MergeLoop1, MergeLoop1Exit, MergeLoop2, MergeLoop2Exit,MergeWhileLoop1, MergeWhileLoop1Exit,
                          MergeWhileLoop1Case1, MergeWhileLoop1Case2, MergeWhileLoop1IfElseEnd, MergeWhileLoop2, MergeWhileLoop2Exit,
                          MergeWhileLoop3, MergeWhileLoop3Exit,resume_prog;
    OblectamentaDataLabel zero,key,int_width,four,one;
                        
                        Merge; //MERGE(A,p,q,r)                            
                            func_prologue{};
                            
                            val A =  8;
                            val p =  16;
                            val q = 20;
                            val r = 24;
                            // reserve space for local variables i,j,k,l,nL,nR
                            val i = -20;
                            val j = i - 4;
                            val k = j - 4;
                            val l = k - 4;
                            val nL = l -4;
                            val nR = nL - 4;
                            ldi64(SP-24);
                            sti64(SP);                            


                            ldi64(FP + p);
                            ldsi32;
                            ldi64(FP + q);
                            ldsi32;
                            subi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + nL);
                            stsi32; // nL = q - p + 1

                            ldi64(FP+q);
                            ldsi32;
                            ldi64(FP+r);
                            ldsi32;
                            subi32;

                            ldi64(FP + nR);
                            stsi32; // nR = r - q

                            //let L[0:nL-1] and R[0:nR-1] be new arrays
                            val L = nR - 8; // L holds the address of L on the stack
                            val R = L - 8;

                            ldi64(SP-16);
                            sti64(SP);  //reserve space for L,R

                            ldi32(int_width);
                            ldi64(FP + nL);
                            ldsi32;
                            muli32;
                            ui32toui64;
                            ldi64(SP);
                            subi64;
                            sti64(SP); //Reserve space for L array on stack
                            ldi64(SP);
                            ldi64(FP + L);
                            stsi64;  // L = address of new array with nL elements
                            
                            ldi32(int_width);
                            ldi64(FP + nR);
                            ldsi32;
                            muli32;
                            ui32toui64;
                            ldi64(SP);
                            subi64;
                            sti64(SP); //Reserve space for R array on stack
                            ldi64(SP);
                            ldi64(FP + R);
                            stsi64;  // R = address of new array with nR elements

                            ldi32(zero);
                            ldi64(FP + i);
                            stsi32;

                        MergeLoop1;
                            ldi64(FP + i);
                            ldsi32;
                            ldi64(FP + nL);
                            ldsi32;
                            lteqi32;
                            bnzeroi32(MergeLoop1Exit); //for i = 0 to nL - 1

                            //L[i] = A[p+i]
                            
                            ldi64(FP + A);
                            ldsi64;
                            ldi64(FP + p);
                            ldsi32;
                            ldi64(FP + i);
                            ldsi32;
                            addi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            ldsi32; //compute_stack.top == A[p+i]
                            ldi64(FP + L);
                            ldsi64;
                            ldi64(FP+i);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            stsi32;

                            ldi64(FP + i);
                            ldsi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + i);
                            stsi32;
                            buc(MergeLoop1);
                        MergeLoop1Exit;

                            ldi32(zero);
                            ldi64(FP + j);
                            stsi32;

                        MergeLoop2;
                            ldi64(FP + j);
                            ldsi32;
                            ldi64(FP + nR);
                            ldsi32;
                            lteqi32;
                            bnzeroi32(MergeLoop2Exit); //for j = 0 to nR - 1
                            // R[j] = A[q + j + 1]
                            ldi64(FP + A);
                            ldsi64;
                            ldi64(FP + q);
                            ldsi32;
                            ldi64(FP + j);
                            ldsi32;
                            addi32;
                            ldi32(one);
                            addi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            ldsi32;
                            ldi64(FP + R);
                            ldsi64;
                            ldi64(FP + j);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            stsi32;

                            ldi64(FP + j);
                            ldsi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + j);
                            stsi32;
                            buc(MergeLoop2);
                        MergeLoop2Exit;

                        
                            // i indexes the smallest remaining element in L
                            ldi32(zero);
                            ldi64(FP + i);
                            stsi32; // i <- 0
                            // j indexes the smalles remaining element in R
                            ldi32(zero);
                            ldi64(FP + j);
                            stsi32; // j <- 0
                            ldi64(FP + p);
                            ldsi32;
                            ldi64(FP + k);
                            stsi32; // k <- p

                            // As long as each of the arrays L and R contains an unmerged element,
                            // copy the smalles umerged element back into A[p:r]

                        MergeWhileLoop1; // while i < nL and j < nR

                            ldi64(FP + i);
                            ldsi32;
                            ldi64(FP + nL);
                            ldsi32;
                            gti32;
                            bzeroi32(MergeWhileLoop1Exit);

                            ldi64(FP + j);
                            ldsi32;
                            ldi64(FP + nR);
                            ldsi32;
                            gti32;
                            bzeroi32(MergeWhileLoop1Exit);
                            
                                                     
                            ldi64(FP + L);
                            ldsi64;
                            ldi64(FP + i);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            ldsi32; // L[i]
                            
                            ldi64(FP + R);
                            ldsi64;
                            ldi64(FP + j);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            ldsi32; // R[j]
                            gteqi32;
                            bzeroi32(MergeWhileLoop1Case2);
                        MergeWhileLoop1Case1; //if L[i] <= R[j]
                            ldi64(FP + L);
                            ldsi64;
                            ldi64(FP + i);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            ldsi32; // L[i]
                            ldi64(FP + A);
                            ldsi64;
                            ldi64(FP + k);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            stsi32; // A[k] = L[i]                            

                            ldi64(FP + i);
                            ldsi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + i);
                            stsi32; // i <- i + 1

                            buc(MergeWhileLoop1IfElseEnd);
                        MergeWhileLoop1Case2; //else

                            ldi64(FP + R);
                            ldsi64;
                            ldi64(FP + j);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            ldsi32; // R[j]
                            ldi64(FP + A);
                            ldsi64;
                            ldi64(FP + k);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            stsi32; // A[k] = R[j]                            

                            ldi64(FP + j);
                            ldsi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + j);
                            stsi32;// j <- j + 1

                        MergeWhileLoop1IfElseEnd;
                            ldi64(FP + k);
                            ldsi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + k);
                            stsi32; //k <- k + 1                     
                            buc(MergeWhileLoop1);
                        MergeWhileLoop1Exit;


                        // Having gone through one of L and R entirely, copy the
                        // remainder of the other to the end of A[p:r]
                     
                        MergeWhileLoop2; 
                        //while i < nL 
                        // A[k] = L[i]
                        // i = i + 1
                        // k = k + 1
                            ldi64(FP + nL);
                            ldsi32;
                            ldi64(FP + i);
                            ldsi32;       
                            lti32;
                            bzeroi32(MergeWhileLoop2Exit);

                            ldi64(FP + L);
                            ldsi64;
                            ldi64(FP + i);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            ldsi32; // L[i]

                            ldi64(FP + A);
                            ldsi64;
                            ldi64(FP + k);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            stsi32; // A[k] = L[i]

                            ldi64(FP + i);
                            ldsi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + i);
                            stsi32; // i = i + 1;

                            ldi64(FP + k);
                            ldsi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + k);
                            stsi32; // k = k + 1;

                            buc(MergeWhileLoop2);
                        MergeWhileLoop2Exit;

                        MergeWhileLoop3;
                        //while j < nR 
                        // A[k] = R[j]
                        // j = j + 1
                        // k = k + 1
                            ldi64(FP + nR);
                            ldsi32;
                            ldi64(FP + j);
                            ldsi32;
                            lti32;
                            bzeroi32(MergeWhileLoop3Exit);

                            ldi64(FP + R);
                            ldsi64;
                            ldi64(FP + j);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            ldsi32; // R[j]

                            ldi64(FP + A);
                            ldsi64;
                            ldi64(FP + k);
                            ldsi32;
                            ldi32(int_width);
                            muli32;
                            ui32toui64;
                            addi64;
                            stsi32; // A[k] = R[j]

                            ldi64(FP + j);
                            ldsi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + j);
                            stsi32; // j = j + 1;

                            ldi64(FP + k);
                            ldsi32;
                            ldi32(one);
                            addi32;
                            ldi64(FP + k);
                            stsi32; // k = k + 1;

                            buc(MergeWhileLoop3);

                        MergeWhileLoop3Exit;
                            
                            // cleanup stack allocated arrays
                            ldi32(int_width);
                            ldi64(FP + nL);
                            ldsi32;
                            muli32;
                            ui32toui64;
                            ldi64(SP);
                            addi64;
                            sti64(SP);

                            ldi32(int_width);
                            ldi64(FP + nR);
                            ldsi32;
                            muli32;
                            ui32toui64;
                            ldi64(SP);
                            addi64;
                            sti64(SP);

                            ldi64(SP+16);
                            sti64(SP);

                            ldi64(SP+24);
                            sti64(SP);

                            func_epilogue{};
};



Scenario{
    title{label __ title = "MERGE ( <1 4 5 6 7 8 9 10> <2 3> ) ";};
    // MERGE(A,p,q,r), see p.36 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaDataLabel arg_p, arg_q,arg_r,zero,int_width,four,one,array;
    OblectamentaCodeLabel Merge;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     1;4;5;6;7;8;9;10;2;3;
                    arg_p;0;
                    arg_q;7;
                    arg_r;9;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    };
                text{
                    asm{
                            pushi32Var{arg_r;};  //|
                            pushi32Var{arg_q;};  //|
                            pushi32Var{arg_p;};  //|
                            pushAddr{array;};    //|
                            call(Merge);         //| ==> Merge(array, arg_p, arg_q, arg_r);
                            halt;                // stop execution
                            merge_text{};       
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
      verdict{equality_test{ 
            {   
                the_vm.vm.data.content().slice(0,41);
            }
            {
                array;
                for(i: 1 .. 10){
                    as_uint8(i);for(i: 1 .. 3){as_uint8(0);}
                }
            }
        };};        
    };
};

Scenario{
    title{label __ title = "MERGE ( <1> <10> ) ";};
    // MERGE(A,p,q,r), see p.36 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaDataLabel arg_p, arg_q,arg_r,zero,int_width,four,one,array;
    OblectamentaCodeLabel Merge;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     1;10;
                    arg_p;0;
                    arg_q;0;
                    arg_r;1;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    };
                text{
                    asm{
                            pushi32Var{arg_r;};  //|
                            pushi32Var{arg_q;};  //|
                            pushi32Var{arg_p;};  //|
                            pushAddr{array;};    //|
                            call(Merge);         //| ==> Merge(array, arg_p, arg_q, arg_r);
                            halt;                // stop execution
                            merge_text{};       
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
      verdict{equality_test{ 
            {   
                the_vm.vm.data.content().slice(0,9);
            }
            {
                array;
                as_uint8(1);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(10);for(i: 1 .. 3){as_uint8(0);}
            }
        };};        
    };
};

Scenario{
    title{label __ title = "MERGE ( <10> <1> ) ";};
    // MERGE(A,p,q,r), see p.36 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaDataLabel arg_p, arg_q,arg_r,zero,int_width,four,one,array;
    OblectamentaCodeLabel Merge;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     10;1;
                    arg_p;0;
                    arg_q;0;
                    arg_r;1;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    };
                text{
                    asm{
                            pushi32Var{arg_r;};  //|
                            pushi32Var{arg_q;};  //|
                            pushi32Var{arg_p;};  //|
                            pushAddr{array;};    //|
                            call(Merge);         //| ==> Merge(array, arg_p, arg_q, arg_r);
                            halt;                // stop execution
                            merge_text{};       
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
      verdict{equality_test{ 
            {   
                the_vm.vm.data.content().slice(0,9);
            }
            {
                array;
                as_uint8(1);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(10);for(i: 1 .. 3){as_uint8(0);}
            }
        };};        
    };
};

Scenario{
    title{label __ title = "MERGE ( <10> <1 2> ) ";};
    // MERGE(A,p,q,r), see p.36 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaDataLabel arg_p, arg_q,arg_r,zero,int_width,four,one,array;
    OblectamentaCodeLabel Merge;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     10;1;2;
                    arg_p;0;
                    arg_q;0;
                    arg_r;2;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    };
                text{
                    asm{
                            pushi32Var{arg_r;};  //|
                            pushi32Var{arg_q;};  //|
                            pushi32Var{arg_p;};  //|
                            pushAddr{array;};    //|
                            call(Merge);         //| ==> Merge(array, arg_p, arg_q, arg_r);
                            halt;                // stop execution
                            merge_text{};       
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
      verdict{equality_test{ 
            {   
                the_vm.vm.data.content().slice(0,13);
            }
            {
                array;
                as_uint8(1);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(2);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(10);for(i: 1 .. 3){as_uint8(0);}
            }
        };};        
    };
};

Scenario{
    title{label __ title = "MERGE ( <1 10> <2> ) ";};
    // MERGE(A,p,q,r), see p.36 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaDataLabel arg_p, arg_q,arg_r,zero,int_width,four,one,array;
    OblectamentaCodeLabel Merge;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     1;10;2;
                    arg_p;0;
                    arg_q;1;
                    arg_r;2;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    };
                text{
                    asm{
                            pushi32Var{arg_r;};  //|
                            pushi32Var{arg_q;};  //|
                            pushi32Var{arg_p;};  //|
                            pushAddr{array;};    //|
                            call(Merge);         //| ==> Merge(array, arg_p, arg_q, arg_r);
                            halt;                // stop execution
                            merge_text{};       
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
      verdict{equality_test{ 
            {   
                the_vm.vm.data.content().slice(0,13);
            }
            {
                array;
                as_uint8(1);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(2);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(10);for(i: 1 .. 3){as_uint8(0);}
            }
        };};        
    };
};


Scenario{
    title{label __ title = "MERGE ( <1 10> <2 3> ) ";};
    // MERGE(A,p,q,r), see p.36 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaDataLabel arg_p, arg_q,arg_r,zero,int_width,four,one,array;
    OblectamentaCodeLabel Merge;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     1;10;2;3;
                    arg_p;0;
                    arg_q;1;
                    arg_r;3;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    };
                text{
                    asm{
                            pushi32Var{arg_r;};  //|
                            pushi32Var{arg_q;};  //|
                            pushi32Var{arg_p;};  //|
                            pushAddr{array;};    //|
                            call(Merge);         //| ==> Merge(array, arg_p, arg_q, arg_r);
                            halt;                // stop execution
                            merge_text{};       
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
      verdict{equality_test{ 
            {   
                the_vm.vm.data.content().slice(0,17);
            }
            {
                array;
                as_uint8(1);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(2);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(3);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(10);for(i: 1 .. 3){as_uint8(0);}
            }
        };};        
    };
};

Scenario{
    title{label __ title = "MERGE ( 1 2 <3> <4> ) ";};
    // MERGE(A,p,q,r), see p.36 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaDataLabel arg_p, arg_q,arg_r,zero,int_width,four,one,array;
    OblectamentaCodeLabel Merge;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     1;2;3;4;
                    arg_p;2;
                    arg_q;2;
                    arg_r;3;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    };
                text{
                    asm{
                            pushi32Var{arg_r;};  //|
                            pushi32Var{arg_q;};  //|
                            pushi32Var{arg_p;};  //|
                            pushAddr{array;};    //|
                            call(Merge);         //| ==> Merge(array, arg_p, arg_q, arg_r);
                            halt;                // stop execution
                            merge_text{};       
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
      verdict{equality_test{ 
            {   
                the_vm.vm.data.content().slice(0,17);
            }
            {
                array;
                as_uint8(1);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(2);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(3);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(4);for(i: 1 .. 3){as_uint8(0);}
            }
        };};        
    };
};

Scenario{
    title{label __ title = "MERGE ( <3 5 6 8> <1 2 4 7> ) ";};
    // MERGE(A,p,q,r), see p.36 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaDataLabel arg_p, arg_q,arg_r,zero,int_width,four,one,array;
    OblectamentaCodeLabel Merge;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     3;5;6;8;1;2;4;7;
                    arg_p;0;
                    arg_q;3;
                    arg_r;7;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    };
                text{
                    asm{
                            pushi32Var{arg_r;};  //|
                            pushi32Var{arg_q;};  //|
                            pushi32Var{arg_p;};  //|
                            pushAddr{array;};    //|
                            call(Merge);         //| ==> Merge(array, arg_p, arg_q, arg_r);
                            halt;                // stop execution
                            merge_text{};       
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
      verdict{equality_test{ 
            {   
                the_vm.vm.data.content().slice(0,33);
            }
            {
                array;
                as_uint8(1);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(2);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(3);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(4);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(5);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(6);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(7);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(8);for(i: 1 .. 3){as_uint8(0);}
            }
        };};        
    };
};

Scenario{
    title{label __ title = "MERGE-SORT <8 7 1 5 4 3 2 6>";};
    // MERGE-SORT(A,p,r), see p.39 in Cormen et.al. 'Algorithms' 4th ed.
    // Indices start at zero which differs from Cormen et. al. where indices start at 1.
    // The temporary arrays L,R are allocated on the stack, Cormen et. al. make no assumptions about the origins of L and R.
    // Because we make 

    OblectamentaDataLabel arg_p, arg_q,arg_r,zero,int_width,four,one,array, two;
    OblectamentaCodeLabel Merge,MergeSort,MergeSortExit;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    array;
                     //12;3;7;9;14;6;11;2;
                     8;7;1;5;4;3;2;6;
                    arg_p;0;
                    arg_r;7;
                    zero;
                     0;
                    one; 
                     1;
                    int_width;
                     4;
                    two; 2;
                    };
                text{
                    asm{
                            pushi32Var{arg_r;};  //|
                            pushi32Var{arg_p;};  //|
                            pushAddr{array;};    //|
                            call(MergeSort);     //| ==> MergeSort(array, arg_p, arg_r);
                            halt;                // stop execution
                            merge_text{};
                        MergeSort;
                            func_prologue{};
                            ldi64(SP-4);
                            sti64(SP); // allocate space for local variables
                            val q = -20;

                            val p = 16;
                            val r = 20;
                            val A = 8;

                            ldi64(FP + r);
                            ldsi32;
                            ldi64(FP + p);
                            ldsi32;
                            gteqi32;
                            bnzeroi32(MergeSortExit); // zero or one element?

                            ldi32(two);
                            ldi64(FP + p);
                            ldsi32;
                            ldi64(FP + r);
                            ldsi32;
                            addi32;
                            divi32;
                            ldi64(FP + q);
                            stsi32;// q = floor((p+r)/2) //midpoint of A[p:r]

                            ldi64(FP + q);
                            ldsi32;
                            ldi64(SP - 4);
                            stsi32;
                            ldi64(SP - 4);
                            sti64(SP);

                            ldi64(FP + p);
                            ldsi32;
                            ldi64(SP - 4);
                            stsi32;
                            ldi64(SP - 4);
                            sti64(SP);

                            ldi64(FP + A);
                            ldsi64;
                            ldi64(SP - 8);
                            stsi64;
                            ldi64(SP - 8);
                            sti64(SP);
                            
                            call(MergeSort);//MergeSort(A,p,q)
                            ldi64(SP + 16);
                            sti64(SP);
                                                        
                            ldi64(FP + r);
                            ldsi32;
                            ldi64(SP - 4);
                            stsi32;
                            ldi64(SP - 4);
                            sti64(SP);

                            ldi64(FP + q);
                            
                            ldsi32;
                            ldi32(one);
                            addi32;

                            ldi64(SP - 4);
                            stsi32;
                            ldi64(SP - 4);
                            sti64(SP);

                            ldi64(FP + A);
                            ldsi64;
                            ldi64(SP - 8);
                            stsi64;
                            ldi64(SP - 8);
                            sti64(SP);
                            
                            call(MergeSort);//MergeSort(A, q + 1, r)                            

                            ldi64(SP + 16);
                            sti64(SP);

                            ldi64(FP + r);
                            ldsi32;
                            ldi64(SP - 4);
                            stsi32;
                            ldi64(SP - 4);
                            sti64(SP);

                            ldi64(FP + q);
                            ldsi32;
                            ldi64(SP - 4);
                            stsi32;
                            ldi64(SP - 4);
                            sti64(SP);

                            ldi64(FP + p);
                            ldsi32;
                            ldi64(SP - 4);
                            stsi32;
                            ldi64(SP - 4);
                            sti64(SP);

                            ldi64(FP + A);
                            ldsi64;
                            ldi64(SP - 8);
                            stsi64;
                            ldi64(SP - 8);
                            sti64(SP);
                            call(Merge); //Merge(A,p,q,r)

                            ldi64(SP + 20);
                            sti64(SP);                            


                        MergeSortExit;

                            ldi64(SP+4);
                            sti64(SP); // deallocate space for local variables

                            func_epilogue{};     
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
          verdict{equality_test{ 
            {   
                the_vm.vm.data.content().slice(0,33);
            }
            {
                array;
                as_uint8(1);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(2);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(3);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(4);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(5);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(6);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(7);for(i: 1 .. 3){as_uint8(0);}
                as_uint8(8);for(i: 1 .. 3){as_uint8(0);}
            }
        };};                
    };
};



Scenario{
    title{label __ title = "MAX-ELEMENT";};

    OblectamentaCodeLabel start,stop,inc_i;
    OblectamentaDataLabel four,one,array, result, i, n;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    result; 0;
                    one;1;
                    four;4;0;
                    n;10;
                    array; 1;2;3;4;55;6;7;8;9;10;
                    i;0;
                };
                text{
                    asm{
                        ldi32(n);         // |
                        ldi32(i);         // |
                        lti32;            // |
                        bzeroi32(stop);   // | i >= n then stop

                        ldi32(array);     // | 
                        sti32(result);    // |
                        buc(inc_i);       // | result = array[0], goto end of loop

                    start;
                        ldi32(n);
                        ldi32(i);
                        lti32;
                        bzeroi32(stop);

                        lea(array);      // |
                        ldi32(i);        // |
                        ui32toui64;      // |                 
                        ldi64(four);     // |
                        muli64;          // |
                        addi64;          // |
                        ldsi32;          // | top compute stack = array[i]
                        
                        ldi32(result);  
                        gteqi32;
                        bnzeroi32(inc_i);

                        lea(array);      // |
                        ldi32(i);        // |
                        ui32toui64;      // |                 
                        ldi64(four);     // |
                        muli64;          // |
                        addi64;          // |
                        ldsi32;          // | top compute stack = array[i]

                        sti32(result);
                    inc_i;
                        ldi32(one);       // |
                        ldi32(i);         // |
                        addi32;           // |
                        sti32(i);         // | i <- i + 1

                        buc(start);
                    stop;                        
                        halt;
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
        verdict{equality_test{ 
            {the_vm.vm.data.content().at(1);the_vm.vm.data.content().at(2);the_vm.vm.data.content().at(3);the_vm.vm.data.content().at(4);}
            {
                as_uint8(55);as_uint8(0);as_uint8(0);as_uint8(0);
            }
        };};
    };
};



Scenario{
    title{label __ title = "MAX-HEAPIFY";};

    OblectamentaCodeLabel l1,l2,l3,l4,start,stop,inc_i;
    OblectamentaDataLabel A,largest,four,one,two,array, result, i, n, l, r, heap_size;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                     A; 16;4;10;14;7;9;3;2;8;1;
                    result; 0;
                    one;1;
                    two;2;
                    four;4;0;
                    n;10;
                    // MAX-HEAPIFY(A,i), see p.165 in Cormen et.al. 'Algorithms' 4th ed.
                    // indices start at zero in contrast to Cormen et. al.
                    i;1;
                    heap_size;10;
                    //local variables
                    l; 0;
                    r; 0;
                    largest; -1;
                };
                text{
                    asm{
                    start;
                      
                      ldi32(i);
                      ldi32(two);
                      muli32;                                           
                      ldi32(one);
                      addi32; 
                      sti32(l); // left = 2*i + 1
                      ldi32(i);
                      ldi32(two);
                      muli32;
                      ldi32(two);
                      addi32;
                      sti32(r); //right = 2*i + 2
                      
                      //if l < A.heap-size and A[l] > A[i]
                      //largest = l
                      
                      ldi32(l);
                      ldi32(heap_size);
                      lteqi32;
                      bnzeroi32(l1);
                      ldi32(i);
                      ldi32(four);
                      muli32;
                      ui32toui64;
                      lea(A);
                      addi64;
                      ldsi32; // top(cstack) = A[i]
                      ldi32(l);
                      ldi32(four);
                      muli32;
                      ui32toui64;                      
                      lea(A);
                      addi64;
                      ldsi32; //cstack = {A[i]; A[l];}
                      lteqi32;
                      bnzeroi32(l1);
                      ldi32(l);
                      lea(largest);
                      stsi32; // mem[popi64(cstack)] = popi32(cstack)
                      buc(l3);
                    l1; //else largest = i
                      ldi32(i);
                      lea(largest);
                      stsi32;
                    l3;
                      //if r < A.heap-size and A[r] > A[largest]
                      ldi32(r);
                      ldi32(heap_size);
                      gteqi32;
                      bzeroi32(l4);
                      lea(A);
                      ldi32(r);
                      ldi32(four);
                      muli32;
                      ui32toui64;
                      addi64;
                      ldsi32; // cstack={A[r]}

                      lea(A);
                      ldi32(largest);
                      ldi32(four);
                      muli32;
                      ui32toui64;
                      addi64;
                      ldsi32; // cstack={A[r],A[largest]}
                      gteqi32;
                      bnzeroi32(l4);
                      ldi32(r);
                      lea(largest);
                      stsi32;
                    l4;
                      ldi32(i);
                      ldi32(largest);
                      eqi32;
                      bnzeroi32(stop); //if A[i] == A[largest] then goto stop
                      lea(A);
                      ldi32(i);
                      ldi32(four);
                      muli32;
                      ui32toui64;
                      addi64;
                      ldsi32;
                      
                      
                      lea(A);
                      ldi32(largest);
                      ldi32(four);
                      muli32;
                      ui32toui64;
                      addi64;
                      ldsi32;

                      lea(A);
                      ldi32(i);
                      ldi32(four);
                      muli32;
                      ui32toui64;
                      addi64;
                      stsi32;

                      lea(A);
                      ldi32(largest);
                      ldi32(four);
                      muli32;
                      ui32toui64;
                      addi64;
                      stsi32;
                      ldi32(largest);
                      lea(i);
                      stsi32;
                      buc(start);


                    stop;                        
                        halt;
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
    Then
    {
        verdict{equality_test{ 
            {
                the_vm.vm.data.content().slice(1,41);
            }
            {
                as_uint8(16);as_uint8(0);as_uint8(0);as_uint8(0);
                as_uint8(14);as_uint8(0);as_uint8(0);as_uint8(0);
                as_uint8(10);as_uint8(0);as_uint8(0);as_uint8(0);
                as_uint8(8);as_uint8(0);as_uint8(0);as_uint8(0);
                as_uint8(7);as_uint8(0);as_uint8(0);as_uint8(0);
                as_uint8(9);as_uint8(0);as_uint8(0);as_uint8(0);
                as_uint8(3);as_uint8(0);as_uint8(0);as_uint8(0);
                as_uint8(2);as_uint8(0);as_uint8(0);as_uint8(0);
                as_uint8(4);as_uint8(0);as_uint8(0);as_uint8(0);
                as_uint8(1);as_uint8(0);as_uint8(0);as_uint8(0);

            }
        };};
    };
};


/*
Scenario{
    title{label __ title = "MAX-HEAPIFY";};

    OblectamentaCodeLabel l1,l2,l3,l4,start,stop,inc_i;
    OblectamentaDataLabel zero,A,largest,four,one,two,array, result, i, n, l, r, heap_size;

    Given{
        
        let the_vm = obj(
            vm{
                compute_stack{
                };
                data{
                    A; 16;4;10;14;7;9;3;2;8;1;
                    result; 0;
                    one;1;
                    two;2;
                    zero;0;
                    four;4;0;
                    n;10;
                    // MAX-HEAPIFY(A,i), see p.165 in Cormen et.al. 'Algorithms' 4th ed.
                    // indices start at zero in contrast to Cormen et. al.
                    i;1;
                    heap_size;10;
                    //local variables
                    l; 0;
                    r; 0;
                    largest; -1;
                };
                text{
                    asm{
                    for(i : 1 .. 1500) {ldi32(one);}

  
                    stop;                        
                        halt;
                    };
                };
            }
        );
     };
    When{
        let the_vm = operation(
         run{
            the_vm;    
          }
        );
     };
     //the_vm;
    Then
    {
    };
};
*/

docinfo_se("==================================== SUMMARY ======================================
");

Summary{
 for( e : root.Scenario){
  e.title.content();e.Then.result.content();
 }
};