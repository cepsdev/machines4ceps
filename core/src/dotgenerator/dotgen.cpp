#define _CRT_SECURE_NO_WARNINGS

#include "core/include/state_machine_simulation_core.hpp"
#include "core/include/base_defs.hpp"
#include <map>
#include <iostream>
#include <set>
#include <unordered_set>
#include <queue>
#include "core/include/dotgenerator/dotgen.hpp"
 
using namespace ceps::ast;

static std::string replace_all(std::string str, const std::string& from, const std::string& to) {
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length(); // Handles case where 'to' is a substring of 'from'
    }
    return str;
}

State_machine* get_sm(std::pair<std::string,State_machine*> const & elem){
	return elem.second;
}

bool is_toplevel_sm(std::pair<std::string,State_machine*> const & elem){
	return elem.first.find('.') == std::string::npos;
}

std::string full_name_of_sm(std::pair<std::string,State_machine*> const & elem){
	return elem.first;
}
template<typename F, typename T,typename S> void traverse_sm(std::unordered_set<State_machine*>& m,State_machine* sm, T const & sms,std::string name,bool traverse_sub_sms, F f,S& s){
	f(sm,name);
	if (!traverse_sub_sms) return;
	for(auto state: sm->states()){
		if (!state->is_sm() || state->smp() == nullptr) continue;
		if (m.find(state->smp()) != m.end()) continue;
		m.insert(state->smp());
		traverse_sm(m,state->smp(),sms,name+"."+state->id_,traverse_sub_sms,f,s);
	}

	for(auto subsm: sm->children()){
		//assert(m.find(subsm) != m.end());
		if (m.find(subsm) != m.end()) continue;
		m.insert(subsm);
		traverse_sm(m,subsm,sms,name+"."+subsm->id_,traverse_sub_sms,f,s);
	}
}

template<typename F, typename T, typename S> void traverse_sms(T const & sms, bool traverse_sub_sms, F f,S& s){
	std::unordered_set<State_machine*> m;
	for(auto sm_: sms){
	 if(!is_toplevel_sm(sm_)) continue;
	 auto sm = get_sm(sm_);
	 if (m.find(sm) != m.end()) continue;
	 traverse_sm(m,sm,sms,full_name_of_sm(sm_),traverse_sub_sms,f,s);
	 m.insert(sm);
	}
}

static void write_copyright_and_timestamp(std::ostream& out, std::string title,bool b,Result_process_cmd_line const& result_cmd_line){
	if(!b) return;
	time_t timer;time(&timer);tm * timeinfo;timeinfo = localtime(&timer);
	out
		<< "/* "<< title <<" " << std::endl
		<< "   CREATED " << asctime(timeinfo) << std::endl
		<< "   GENERATED BY THE sm4ceps C++ GENERATOR VERSION 0.80 (c) 2016 Tomas Prerovsky <tomas.prerovsky@gmail.com>, ALL RIGHTS RESERVED. \n"
		<< "   BASED ON cepS "<< ceps::get_version_info() << "\n\n"

		<< "   Input files:\n";
	for( auto const & f: result_cmd_line.definition_file_rel_paths) {
	out << "      "<< f << "\n";
	}

	out << "\n";
	out	<< "   THIS IS A GENERATED FILE.\n\n"
		<< "   *** DO NOT MODIFY. ***\n*/\n"
		<< std::endl << std::endl;
}

class Dotgenerator{
	std::map<std::string,std::string> n2dotname;
	std::map<State_machine*,std::string> sm2dotname;
	std::map<State_machine*,std::string> sm2initial;

	std::string pure_state_base_style_ = "style=\"rounded\"";
	void dump_sm(std::ostream& o,std::string name,State_machine* sm);
public:
	std::string pure_state_base_style(){return pure_state_base_style_;}

	friend State_machine_simulation_core;
};


void Dotgenerator::dump_sm(std::ostream& o,std::string name,State_machine* sm){
	 o << " subgraph "<<n2dotname[name]<<"{\n";
	 o << "  label=\"" << sm->id() << "\";\nfontname=\"Arial\";\nfontsize=60;\n";

	 for(auto const& s:sm->states()) if (!s->is_sm_){
		 std::string t = n2dotname[name+"."+s->id()];
		 o << " "<<t<<"[label=\""<<s->id() << "\"," <<pure_state_base_style()<< ",fontsize=50];\n";
	 }

	 for(auto subsm:sm->children()){
		 dump_sm(o,name+"."+subsm->id(),subsm);
	 }

	 for(auto& t : sm->transitions()){
		 if ( (t.from_.parent_ == sm || t.from_.parent_ == nullptr)&& (t.to_.parent_ == sm || t.to_.parent_ == nullptr) && !(t.from_.is_sm_ || t.to_.is_sm_) ){
			 o << n2dotname[name+"."+t.from_.id()] << "->" << n2dotname[name+"."+t.to_.id()] << "[penwidth=6];\n";
		 }
		 if (!t.from_.is_sm_ && t.to_.is_sm_){
			 o << n2dotname[name+"."+t.from_.id()] << "->" <<sm2initial[t.to_.smp_] << "[lhead=\""<< sm2dotname[t.to_.smp_] << "\",penwidth=6];\n";
		 }
	 }
	 o << " }\n";
}

void State_machine_simulation_core::do_generate_dot_code(ceps::Ceps_Environment& ceps_env,
													  ceps::ast::Nodeset& universe,
													  std::map<std::string, ceps::ast::Nodebase_ptr> const & all_guards,
													  Result_process_cmd_line const& result_cmd_line){

	std::ofstream o{"out.dot"};
	int cluster_counter = 0;
	int pure_state_counter = 0;
	Dotgenerator dotgen;
	write_copyright_and_timestamp(o, "out.dot",true,result_cmd_line);
	o << "digraph Root {\ncompound=true;\nnodesep=1.1;\nnode [shape=box, fontname=\"Arial\"];\n";

	auto map_names = [&](State_machine* sm,std::string name){
		dotgen.n2dotname[name] = "cluster"+std::to_string(cluster_counter);
		dotgen.sm2dotname[sm] = "cluster"+std::to_string(cluster_counter++);
		for(auto const& s:sm->states()) if (!s->is_sm_){
			dotgen.n2dotname[name+"."+s->id()] = "node"+std::to_string(pure_state_counter++)+"_is_"+s->id();
			if (s->id() == "Initial" || s->id() == "initial") dotgen.sm2initial[sm] = dotgen.n2dotname[name+"."+s->id()];
		}
	};

	auto dump_toplevel_sm = [&](State_machine* sm,std::string name)->void{
		dotgen.dump_sm(o,name,sm);
	};
	traverse_sms(State_machine::statemachines,true,map_names,dotgen);
	traverse_sms(State_machine::statemachines,false,dump_toplevel_sm,dotgen);
	o << "}\n";
}


