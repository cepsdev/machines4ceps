#define _CRT_SECURE_NO_WARNINGS

#include "core/include/state_machine_simulation_core.hpp"
#include "core/include/base_defs.hpp"
#include <map>
#include <iostream>
#include <set>
#include <unordered_set>
#include <queue>
#include "core/include/dotgenerator/dotgen.hpp"
 
using namespace ceps::ast;

static std::string replace_all(std::string str, const std::string& from, const std::string& to) {
    size_t start_pos = 0;
    while((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length(); // Handles case where 'to' is a substring of 'from'
    }
    return str;
}

State_machine* get_sm(std::pair<std::string,State_machine*> const & elem){
	return elem.second;
}

bool is_toplevel_sm(std::pair<std::string,State_machine*> const & elem){
	return elem.first.find('.') == std::string::npos;
}

std::string full_name_of_sm(std::pair<std::string,State_machine*> const & elem){
	return elem.first;
}
template<typename F, typename T,typename S> void traverse_sm(std::unordered_set<State_machine*>& m,State_machine* sm, T const & sms,std::string name,bool traverse_sub_sms, F f,S& s){
    if(!f(sm,name)) return;
	if (!traverse_sub_sms) return;
	for(auto state: sm->states()){
		if (!state->is_sm() || state->smp() == nullptr) continue;
		if (m.find(state->smp()) != m.end()) continue;
		m.insert(state->smp());
        traverse_sm(m,state->smp(),sms,name+"."+state->id_,traverse_sub_sms,f,s);
	}

	for(auto subsm: sm->children()){
		//assert(m.find(subsm) != m.end());
		if (m.find(subsm) != m.end()) continue;
		m.insert(subsm);
        traverse_sm(m,subsm,sms,name+"."+subsm->id_,traverse_sub_sms,f,s);
	}
}

template<typename F, typename T, typename S> void traverse_sms(T const & sms, bool traverse_sub_sms, F f,S& s){
	std::unordered_set<State_machine*> m;
	for(auto sm_: sms){
	 if(!is_toplevel_sm(sm_)) continue;
	 auto sm = get_sm(sm_);
	 if (m.find(sm) != m.end()) continue;
	 traverse_sm(m,sm,sms,full_name_of_sm(sm_),traverse_sub_sms,f,s);
	 m.insert(sm);
	}
}

static void write_copyright_and_timestamp(std::ostream& out, std::string title,bool b,Result_process_cmd_line const& result_cmd_line){
	if(!b) return;
	time_t timer;time(&timer);tm * timeinfo;timeinfo = localtime(&timer);
	out
		<< "/* "<< title <<" " << std::endl
		<< "   CREATED " << asctime(timeinfo) << std::endl
		<< "   GENERATED BY THE sm4ceps C++ GENERATOR VERSION 0.80 (c) 2016 Tomas Prerovsky <tomas.prerovsky@gmail.com>, ALL RIGHTS RESERVED. \n"
		<< "   BASED ON cepS "<< ceps::get_version_info() << "\n\n"

		<< "   Input files:\n";
	for( auto const & f: result_cmd_line.definition_file_rel_paths) {
	out << "      "<< f << "\n";
	}

	out << "\n";
	out	<< "   THIS IS A GENERATED FILE.\n\n"
		<< "   *** DO NOT MODIFY. ***\n*/\n"
		<< std::endl << std::endl;
}

class Dotgenerator{
	std::map<std::string,std::string> n2dotname;
	std::map<State_machine*,std::string> sm2dotname;
	std::map<State_machine*,std::string> sm2initial;

	std::string pure_state_base_style_ = "style=\"rounded\"";
    void dump_sm(std::ostream& o,std::string name,State_machine* sm,std::set<State_machine*>* expand);
	std::string state_style(std::string name){
		if (name == "initial" || name ==  "Initial")
		{
			return "shape=\"point\",width=\"0.15\"";
		}
		if (name == "final" || name ==  "Final")
		{
			return "shape=\"point\",width=\"0.15\",fillcolor=white";
		}
		return pure_state_base_style();
	}

	std::string label(State_machine::State* s){
		if (s->id() == "Initial" || s->id() == "initial" || s->id() == "Final" || s->id() == "final" ) return "xlabel=<<i><FONT POINT-SIZE=\"8\">" +s->id()+ "</FONT></i>>";
		return "label=\""+s->id()+"\"";
	}

	std::string edge_label(State_machine::Transition const & t,State_machine* sm){
	  std::string label_content;

	  for (auto ev : t.events())
	  {
		  label_content+="<B>"+ev.id()+"</B>";
	  }
	  if (t.guard().length()){
		  label_content+="["+t.guard()+"]";
	  }

	  for (auto a : t.actions()){
		  label_content+="<i>/"+a.id()+"();</i> ";
	  }

	  if (label_content.length() == 0) return "";
	  if (t.from_.is_sm_ && t.to_.is_sm_) return ",fontname=\"Courier\",xlabel=< <FONT POINT-SIZE=\"10\">"+label_content+"</FONT> >";
	  return ",fontname=\"Courier\",label=< <FONT POINT-SIZE=\"10\">"+label_content+"</FONT> >";
	}
public:
	std::string pure_state_base_style(){return pure_state_base_style_;}

	friend State_machine_simulation_core;
};


void Dotgenerator::dump_sm(std::ostream& o,std::string name,State_machine* sm,std::set<State_machine*>* expand){
     if (expand != nullptr && expand->find(sm) == expand->end()){
      o << " "<<sm2dotname[sm]<<"[ label=\""<< sm->id() << "\\n...\" ," <<state_style(sm->id())<< ",fontsize=14];\n";
      return;
     }
	 o << " subgraph "<<n2dotname[name]<<"{\n";
	 o << "  label=\"" << sm->id() << "\";\nfontname=\"Arial\";\nfontsize=14;\n";

	 for(auto const& s:sm->states()) if (!s->is_sm_){
		 std::string t = n2dotname[name+"."+s->id()];
		 o << " "<<t<<"["<<label(s) << "," <<state_style(s->id())<< ",fontsize=14];\n";
	 }

	 for(auto subsm:sm->children()){
         dump_sm(o,name+"."+subsm->id(),subsm,expand);
	 }

	 o << " }\n";
}

void State_machine_simulation_core::do_generate_dot_code(std::map<std::string,State_machine*> const & sms,std::set<State_machine*>* expand, std::ostream& o){
    //expand = nullptr;
    int cluster_counter = 0;
    int pure_state_counter = 0;
    Dotgenerator dotgen;
    o << "digraph Root {\ncompound=true;fillcolor=cornsilk;style=\"rounded,filled\";/*\nnodesep=1.1;*/\nnode [shape=box, fontname=\"Arial\"];\n";

    auto map_names = [&](State_machine* sm,std::string name){
        if (expand != nullptr && expand->find(sm) == expand->end()){
            dotgen.n2dotname[name] = dotgen.sm2dotname[sm] = dotgen.sm2initial[sm] = "cluster_proxy"+std::to_string(cluster_counter++);
            for(auto const& s:sm->states()) if (!s->is_sm_){
                dotgen.n2dotname[name+"."+s->id()] = dotgen.sm2initial[sm];
            }
            for(auto s:sm->children())
                dotgen.n2dotname[name+"."+s->id()] = dotgen.n2dotname[name+"."+s->id()] = dotgen.sm2initial[s] = dotgen.sm2initial[sm];

            return false;
        }
        dotgen.n2dotname[name] = "cluster"+std::to_string(cluster_counter);
        dotgen.sm2dotname[sm] = "cluster"+std::to_string(cluster_counter++);
        for(auto const& s:sm->states()) if (!s->is_sm_){
            dotgen.n2dotname[name+"."+s->id()] = "node"+std::to_string(pure_state_counter++)+"_is_"+s->id();
            if (s->id() == "Initial" || s->id() == "initial") dotgen.sm2initial[sm] = dotgen.n2dotname[name+"."+s->id()];
        }
        return true;
    };

    auto dump_toplevel_sm = [&](State_machine* sm,std::string name)->bool{
        dotgen.dump_sm(o,name,sm,expand);return true;
    };

    auto dump_transitions =[&](State_machine* sm, std::string name)->bool{
         bool out_only = false;
         if (expand != nullptr  && expand->find(sm) == expand->end() ) out_only = true;
         for(auto& t : sm->transitions()){
             if (out_only && (!t.to_.is_sm_ || t.to_.smp()->parent() == sm) ) continue;


             if ((t.from_.parent_ == sm || t.from_.parent_ == nullptr)&& (t.to_.parent_ == sm || t.to_.parent_ == nullptr) && !(t.from_.is_sm_ || t.to_.is_sm_) ){
                 if (dotgen.n2dotname.find(name+"."+t.from_.id()) != dotgen.n2dotname.end() && dotgen.n2dotname.find(name+"."+t.to_.id()) != dotgen.n2dotname.end() )
                     o << dotgen.n2dotname[name+"."+t.from_.id()] << "->" << dotgen.n2dotname[name+"."+t.to_.id()] << "[penwidth=1"<<  dotgen.edge_label(t,sm)<<"];\n";
             }
             else if (!t.from_.is_sm_ && t.to_.is_sm_ && dotgen.n2dotname.find(name+"."+t.from_.id()) != dotgen.n2dotname.end() && dotgen.n2dotname.find(name+"."+t.to_.id()) != dotgen.n2dotname.end() ){
                 o << dotgen.n2dotname[name+"."+t.from_.id()] << "->" <<dotgen.sm2initial[t.to_.smp_];
                 if (expand == nullptr  || expand->find(t.to_.smp_) != expand->end())
                     o << "[lhead=\""<< dotgen.sm2dotname[t.to_.smp_] << "\",penwidth=1"<<  dotgen.edge_label(t,sm)<<"]";
                 o << ";\n";
             }
             else if (t.from_.is_sm_ && !t.to_.is_sm_ && dotgen.sm2initial.find(t.from_.smp_) != dotgen.sm2initial.end()){
                 o << dotgen.sm2initial[t.from_.smp_] << "->" << dotgen.n2dotname[name+"."+t.to_.id()];
                 if (expand == nullptr  || expand->find(t.from_.smp_) != expand->end())
                     o << "[ltail=\""<< dotgen.sm2dotname[t.from_.smp_] << "\", penwidth=1"<<  dotgen.edge_label(t,sm)<<"]";
                 o << ";\n";
             }
             else if (t.from_.is_sm_ && t.to_.is_sm_
                     && dotgen.sm2initial.find(t.from_.smp_) != dotgen.sm2initial.end()
                     && dotgen.sm2initial.find(t.to_.smp_) != dotgen.sm2initial.end() ){
                 o << dotgen.sm2initial[t.from_.smp_] << "->" << dotgen.sm2initial[t.to_.smp_];
                 o << "[";
                 if (expand == nullptr  || expand->find(t.from_.smp_) != expand->end())
                 {
                     o << "ltail=\""<< dotgen.sm2dotname[t.from_.smp_] << "\", ";
                 }
                 if (expand == nullptr  || expand->find(t.to_.smp_) != expand->end())
                 {
                     o << "lhead=\""<< dotgen.sm2dotname[t.to_.smp_] << "\", ";
                 }
                 o << "penwidth=1"<<  dotgen.edge_label(t,sm)<<"];\n";
             }             
         }
         return true;
    };
    traverse_sms(sms,true,map_names,dotgen);
    traverse_sms(sms,false,dump_toplevel_sm,dotgen);
    traverse_sms(sms,true,dump_transitions,dotgen);

    o << "}\n";
}

void State_machine_simulation_core::do_generate_dot_code(ceps::Ceps_Environment& ceps_env,
													  ceps::ast::Nodeset& universe,
													  std::map<std::string, ceps::ast::Nodebase_ptr> const & all_guards,
													  Result_process_cmd_line const& result_cmd_line){

	std::ofstream o{"out.dot"};
	write_copyright_and_timestamp(o, "out.dot",true,result_cmd_line);
    do_generate_dot_code(State_machine::statemachines,nullptr,o);
}


